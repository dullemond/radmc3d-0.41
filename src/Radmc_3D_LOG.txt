Nov 2007        Starting with the basic code. Then had to stop for a few
                months.

25.08.08        Continuing writing the basic code. Still lots to do 
                but it is progressing.
                
                Big issue to still resolve: I use ray_x, ray_y, ray_z
                etc but if we want to be able to use also Voronoi and 
                Delaunay grids, then we must make sure to pass these
                as arguments to the amrray module, so that they do not
                conflict with the ray_x,etc from the voronoiray or 
                delaunayray modules. 

                Also: the amrray module still is work in progress in
                the spherical coordinates part. It does not yet work
                (had #### in it). 

                [--> backup_25.08.08.zip]
                

26.08.08        montecarlo_module.f90/do_absorption_event()
                I notice that the array temp(:,:) is competely unused.
                It is set, but not used. The same is true in the original
                montecarlo.F code. I will remove this.

27.08.08        I must now check if the mirror symmetry is implemented
                correctly.

05.09.08        Wow, in the last few days done a lot on the code. Too
                much to really tell here. A major thing is that I improved
                the amr_module.f90 library read/write routines. See that
                library for more info. 

                The code compiles now without error.

                [--> backup_05.09.08.zip]

    ++          I now want to include the possibility to include generic
                dust opacity files, even if they are not mapped to the
                same frequency grid as in frequency.inp. 

10.10.08        I have done a lot of debugging in recent days. One
                particularly nasty bug was that if you have a variable
                as global variable in a module, but ALSO declare them 
                in a local subroutine within the same subroutine, then
                the value of that variable is often undefined and can
                get any strange value between 1D-350 and 1D+350... This
                is what happened with the "energy" variable...

10.10.08        WOW, it seems to work, at least I get reasonable results
                for a 4x4x4 grid around a star.

  ******  With this success we finish version_0.01  ******



-------------------------------------------------------------------------
                           VERSION 0.02
-------------------------------------------------------------------------


15.10.08        Next I think it is important to get the imaging running.
                So I must place a camera somewhere and allow the user
                to specify its position and orientation in a simple way.
                I will take the origin of the coordinate system as
                default focus point, but you can place it anywhere. 

15.10.08
  &&&&&         I changed some of the IO stuff!!!

                It seems to work!

                [---> src_works_1]

                [radmc_v0.02.2.zip]


22.10.08        I implemented color images and movies. 

                [radmc_v0.02.3.zip]

                I now want to change some of the integers into 8-byte integers,
                to prevent wrap-around in the case of very large numbers of
                photons.

                Done.

                I also now do no longer read camera_tracemode from the radmc.inp, but
                I get this from the command-lie.

24.10.08        I now have the movie stuff working. Example:

                   IDL> .r ../src/readradmc.pro
                   IDL> makeimage,sizepc=3.,lambda=1000.,incl=60,phi=360*dindgen(100)/99.,npix=200
                   IDL> linkmovie,/img,sf=4,/log,maxlog=6

                I notice, however, that near the edges of the block there
                are some artifacts. Check this out. 

28.10.08        [radmc_v0.02.4.zip]

  BUG           I still see that there is a slight problem with the images
                near the edges of the box if the box is inclined. I do not
                understand this. 

                But before fixing this, I would like to include a simpler
                zoom-in option. This allows you to specify in detail the 
                lower-left and upper-right corner of the image in units of
                parsec or au or so. 

    &&&         I now removed the
                  if(cameras_img_hs_x(img).ne.0.d0)             
                  if(cameras_img_hs_y(img).ne.0.d0)                 
                statements. I now expect these always to be set.

                Added a cameras_zmc_x,cameras_zmc_y.

  BUG           readradmc.pro
                I still had this weird image mirroring in the plotting
                routine. I found out the problem when I implemented the
                zooming option, when everything went weird. 
                ---> FIXED.

                OK, I can now zoom in very nicely. 

                I can now zoom in to the strange effects on the edge of
                the box. It really looks like a pure edge effect. So not
                something inside. But one cannot be sure.

  BUG           NOTE that there is still this weird bug in the temperature
                computed from the monte carlo run: the temperature is
                low near the edges, even in the very optically thin case.

28.10.08        [radmc_v0.02.5.zip]

                I now want to get to the bottom of these strange things.
                In a test of 3x3x3 cells I find that the temperature in the
                corner cells is 0. Really strange.

   Bug fixed    montecarlo_module.f90
                I found the bug: The amrray_find_next_location_cart() returns
                arrived=.true. if the NEXT section is going to be to 
                infinity, not the current one. But I returned immediately
                from walk_cells() back to the calling routine when arrived
                was .true.. That meant that the last cell did not receive
                any energy. The reason why the boundary cells still got 
                SOME energy was that some photons crossed from one boundary
                cell to the next, so that the first boundary cell got some
                energy. This was, however, much rarer.

                ---> Fixed!

                The temperature drop problem is indeed fixed now, as a test
                has shown.

                But the problem with the image is still there.

29.10.08        viewimage3d.pro
                I have now reimplemented the 3-D image viewer for RADMC-3D.
                Now I added a box-zoom function, which works fantastically!
                Just draw a box on the screen and press make image, and you
                will be zoomed-in to this. You can even recursively zoom
                further. 

                But I really dislike the long loading time for the data.
                I therefore now want to implement the unformatted reading
                and writing.

                   (Postponed: I found a better way to speed things up,
                    see below)

29.10.08        amrray_module.f90

  BUG           I found a bug: Once the grid is entered from outside, only
                the base branch is looked up. If, however, the AMR refinement
                is also active at the border of the box, then we should
                in fact search for possible children...

                    ******* NOT YET FIXED *******

                The problem with the funny rim in the image is still not solved. 

                

29.10.08        [--->radmc_v0.02.6.zip]


29.10.08        Now I want to install the possibility of running radmc-3d
                completely as a child process, i.e. receiving input from 
                the parent and sending its output to the parent. This is
                very useful for linking radmc3d to an IDL widget.

                IT WORKS!!

                Now I also added the possibility to use tabulated exponentials
                to speed up the imaging. 

                Seems to work, but:

                --> The tabulated exponentials do not appear to make much
                    difference in the speed of the computation... :-(

                --> Problem: it appears that the data transfer through the
                    pipe between radmc and IDL is slow. Even if I simply
                    do a 'writeimage' command to radmc, the reading of
                    a 200x200 image takes long...

                OK, so I implement the possibility of unformatted write to
                stdout.

                --> The standard output cannot allow unformatted output :-(

------------------------------------------------------------------------------
         VERSION 0.03
------------------------------------------------------------------------------
                
30.10.08        
     +++        I have made MAJOR improvements to viewimage.pro! It is 
                now really cool, with a zoom box and also a possiblity to
                rotate the image with the mouse. Also things go reasonably
                fast (though, see above) because RADMC3D is now a child
                process.

                Man, that was another full day's work. But I think that in
                the long run this will be worth it. It is now really smooth.

                [--->radmc_v0.03.1.zip]

20.11.08        I now add some more flush statements.
                   call flush(stdo)

10.12.08        dust_module.f90
  bug found     I forgot to close the unit 1 after reading the opacity
                from the dustkappa_*.inp file.

                Is now fixed.

10.12.08        dust_module.f90

  +++++         Added the possibility to:
                 - Use string-like indices (such as dustkappa_silicate.inp)
                 - Compute internally the opacity with Mie or CDE
   &&           and I changed:
                 - Instead of writing dustkappa.inp_remapped I write
                   dustkappa.inp_used, because if we compute the dust
                   opacity internally it is not only a remapping but
                   also a completely newly computed quantity.


13.12.08        [-->dust_module.f90_2]

                In the diskstructevol code I added also the agrain and
                mgrain into the dust module: dust_agrain() and dust_mgrain().
                For compatibility of the dust modules between these two
                codes (avoiding too much deviation), I add these things
                here too.

                [-->dust_module.f90_3]

                Some more modifications.

17.12.08        Tiny modifications to ensure that things compile also   
                with ifort. For instance, in ifort you cannot 'return'
                in the main program. So I replace that with goto 700
                and at the end of the program 700 continue.

This is the version that I installed on
the computer at ITA on december 17, 2008
                

------------------------------------------------------------------------------
         VERSION 0.04
------------------------------------------------------------------------------

17.12.08        I now want to work on imaging which automatically refines
                the density of pixels in an oct-grid way such that all
                details of the object are properly picked up. This does
                not mean that the final image is an AMR-style image. Instead
                what happens is that a normal nx*ny image is made, but if
                a pixel is too large, a recursive call will be made to 
                four subpixels, each of which can recursively call further
                subpixels. Eventually only the average of all intensities
                (properly weighted) will result and be inserted into the
                pixel in the nx*ny image. The refinement is just there 
                to ensure that all the flux is picked up.

   &&&&         But I have to make a big modification here: instead of
                pre-computing and storing all the pixel starting points
                and directions, we do the computating locally.

   &&&&         ioput_module.f90:
                Removed all mcparams arguments. They are not used.

   &&           main.f90:
                Moved the reading of the radmc.inp into a separate subroutine.
                Made sure that all variables are globally accessible. 

                camera_module.f90:
   &&&          Removed the predefined pixel starting points and directions.
                Now these are computed when the ray tracing begins.

   +++          Added a subroutine that computes the intensity of a pixel,
                but that can recursively call itself to refine if necessary.

   ++           Busy including the flux from the stars into the image.
                NOT YET READY.

   ---          Removed camera_make_startpositions(usepos)

18.12.08
   --           Removed camera_direction(:) and camera_observer_dpc

                Still busy reorganizing the camera_module such that the
                ray starting point is calculated locally instead of pre-
                calculated for all pixels (see above). The reason why this
                is necessary is that it otherwise becomes difficult to do
                the recursive pixel rendering.

   +            I added a check that the AMR coordinate system is 
                centered not too far from (0,0,0) (in units of the 
                size of the computational domain). This in order to
                avoid possible numerical issues.

20.12.08        amrray_module.f90:
  BUGG!!        There is still this big bug in the amrray module which
                will appear if the ray enters the grid at a point where
                there is grid refinement.

20.12.08        Still to be done:
                 - Remove indexleaf, only have indexbranch
                 - Return level from amrray_find_next_location_cart
                 - Fix bug in amrray_find_next_location_cart when ray
                   enters grid at a point where there is refinement
                 - Implement dxmin and refinement
                 - Implement rotation for perspective view
                 - Improve efficiency in amrray_find_next_location_cart()
                   in that the arguments are passed through a pointer to
                   a structure.
                 - Add stars to image
                 - Add various sources to the ray tracing in the camera
                   module, such as the continuous stellar sources, PAH
                   emission, scattering etc.

20.12.08        Done:
  BUG FIXED      - Bug of above is now fixed.
                 - In io module checking that AMR grid is cubic (dx=dy=dz)
                   and regularly spaced.
                 - In amrray module: optional return of levelnext
                 - Computation of celldxmin for cartesian (!) AMR coordinates
                 - Recursive pixel rendering done
                 - Removed the starting point and direction arrays, and put
                   the computation of these locally.

                
21.12.08        Done:
                 - Implement rotations for local perspective view

                Busy:
                 - Implementing the point source stars. Look for the
                   #### marks to find where to continue.


  IDEA:         Idea about how to include the line stuff easily. The idea
                here is to put ONLY the velocities at the AMR corners, and
                use the tri-linear interpolation only for the projected
                velocity along the ray. The actual line source terms 
                would then be cell-oriented, just like the dust. This makes
                the dust and the line ray tracing compatible with each other
                and still circumvent the usual problems with the Doppler
                shift.

28.12.08        In the last few days I have off-and-on worked on the camera
                module. Pretty much has been modified.

  IDEA:         One idea how to include the finite size of stars in the 
                camera module in an easy way is to do the following things:

                  - Have an integer for each cell which tells if there is 
                    a star in the cell. If this number is 0, no star is in 
                    the cell. If >0, then the number points to the star.
                    Note that more than one cell can point to the same 
                    star due to the finite size of the star.
                  - Allow only 0 or 1 stars in a cell. No cell is allowed
                    to contain (even part of) more than 1 star.
                  - If a ray passes through a cell with a star:
                    - The dxmin is set to a value that is:
                                max(fact1*d,fact2*rstar)
                      where d is the closest distance of the ray to the
                      center of the star and fact1 and fact2 are to be 
                      set to practical values. Fact2 sets the resolution
                      at which the star will be visible and thereby also
                      the accuracy of the observed stellar flux.
                    - It will be checked if the star is hit. If so, the ray is 
                      continued at the exit point of the star with the intensity 
                      of the star. 
                  - Note that the inclusion of stars following the point source
                    aposteriori method must be switched off.

  IDEA:         I think it is time to allow for in-between-lambda imaging
                capability. This is for two reasons: A) it is annoying that one
                cannot make images at some wavelength one defines in advance
                and B) for the line transfer it is useful because then the
                same ray-tracer as used for the dust can be used for the lines.

30.12.08        
  +++           Finally the flux-conserving imaging is ready!!!! And it appears
                on first sight to work great. Also the viewimage.pro is now
                adapted: it has now a 'preview' button, which is the view mode
                without flux conservation (what it was so far). If the preview
                button is off, then flux-conserved ray-tracing is done, and it
                appears to work. Indeed, for high res it takes equally long
                for preview and non-preview, while for low-rest (try 10!) the
                preview is very fast, while the non-preview (=flux conserved)
                mode is slower, but conserves flux better: pixels that were 
                black before are now non-black because of this. 

  +++           Now also the star point sources are added to the image. Also
                this appears to work fine, although not 100% tested yet. In
                the viewimage you have a button to switch the stars off/on.
                

         [---> radmc-3d_v0.04_30.12.08.zip]


------------------------------------------------------------------------------
         VERSION 0.05
------------------------------------------------------------------------------

31.12.08        I now want to include the possibility to make SEDs/spectra.
                Standard I will simply take the whole thing, i.e. no 
                particular 'beam' or so. 

  PROBLEM?      A potential problem with the recursive pixels:
                I see that there is a potential problem at the edges of the
                box: a ray that passes by the box will not be refined even 
                if it should. I think that this is not a major problem, but
                we should keep this in mind.

  NO PROBLEM:   No, this is not a problem, because even for rays that do
                not enter the grid, the largest dxmax is still that of the
                base grid of the AMR grid. 

                In total I would like to have the following modes:
                 - Full SED
                 - SED in a fixed zoom-box (simple: like images)
                 - SED in a field of view that is lambda dependent

   ++           I added a check that the shortest wavelength is short
                enough to encompass the star spectrum. Will give strong
                warning. 
                ==> It turns out that the model I have so far used for the
                    testing is indeed wrongly gridded in wavelength: the
                    20000 K star does not fit into lambda=[0.1,..], 
                    should take lambda=[0.03,..] or so instead. 


   ++           In the stars.inp it is now also possible (iformat=2) to
                specify the wavelengths in micron instead of the frequencies.

   ++           Now the viewimage.pro GUI automatically writes a little
                IDL script called image_script.pro which, if executed in
                IDL, reproduces the same image as on the screen in the 
                viewimage window. This allows the user to quickly
                understand how images are made, and provides a good
                starting point for possible further off-line (i.e. not
                viewimage) investigation. Note however that the image
                that is displayed is also written to image.out, so the
                image can even be analyzed without the script. But the
                script is also a good memory of the settings that 
                produced the latest image.

   ++           Added many call flush(stdo) statements, to ensure that
                even in child mode the output to the radmc.out is flushed
                regularly.

   &&           In readradmc.pro heb ik spawn,'../src/'+command vervangen
                door spawn,command, omdat de radmc3d code nu globaal 
                aanroepbaar is.

   ++++         In principle the spectrum

01.01.09
  BUG FIX       I accidently used inu for the loop when adding the stars.
                Must be iinu. Fixed.

  bugs fixed    Some smaller bugs in main.f90 fixed with the nrinus and
                so. The spectrum has nrinus = freq_nr, while the images
                have them 1. This also went wrong.

                Still the radmc-as-child goes wrong after doing an
                image, then a spectrum and then again an image... No idea
                why.

  BUG FIXED     Instead of flushing the output in the camera_write_spectrum()
                routine, I accidently closed the file, i.e. the FFLO...
                Fixed.

           [----> radmc_v0.05_01.01.09.zip]

------------------------------------------------------------------------------
         VERSION 0.06
------------------------------------------------------------------------------

02.01.09        The version 0.05 is the first fully operational version 
                of RADMC-3D. But it misses a number of things. For one
                it misses scattering. For big 3-D boxes it is presumably
                not doable to store all the scattering source function,
                even for isotopic scattering. Simple estimation: 128^3 box
                and 100 frequencies in single precision: about 1 GB of
                memory. Writing this to file is enormous. And this is
                only a small box. It seems more reasonable to do the
                scattering source function for 1 or a few frequencies
                only. 

                We can do this with a scattering post-processing. This was
                already planned. Let's see if it can be easily built in...

                
 STILL BUSY     Still working on the scattering Monte Carlo stuff


03.01.09        
   --           dust_module.pro: 
                Removed dust_anisoscat_mode.

   !            I have been thinking about the scattering treatment 
                in case of non-isotropic scattering. Many codes use a
                kind of CCD camera at infinity and collect discrete
                photons. However, this is very computationally expensive
                and may yield very low dynamic range images. 
                    I therefore decide not to include this (at least not
                for the moment) and instead use the direction-dependent
                scattering source terms, plus aposteriori ray-tracing.
                This has worked well for Michiel Min and C. Pinte. 

   +++          I have done a LOT on the Monte Carlo stuff, including the
                anisotropic scattering with the observer's position.
                Wow, it is really a lot of work to get this stuff done.
                The biggest worry is that I may have destroyed the 
                working thermal monte carlo stuff. But I have also
                cleaned it up!

                For now, however, the anisotropic scattering mode is
                only working if dust_nr_species is 1. 

          NOT YET READY!

   IDEA         An idea for the line module: 
                To have it ready as soon as possible I decided today to
                keep the level population filling entirely a task of the
                user. Not even LTE is calculated here, because for that
                we still need to have the partition function. Instead 
                we will simply ask the user to specify the level populations,
                and we will do the ray-tracing.
                
                [---> radmc-3d_v0.06_03.01.09.zip]

11.01.09        [---> radmc-3d_v0.06_11.01.09.zip]

                I now want to generalize the ray-tracing of the lines a
                bit. Instead of having a special line ray-tracing routine
                for the camera, I make a general ray-tracing routine for
                any wavelength. This will include the lines and/or the dust,
                whatever you want. 

20.01.09        Slightly modify the amr_grid.inp format, in particular
                for the unformatted style. [Note: also done in version 0.05]

25.01.09        
  BUGG!! Fixed  When calling read_radmcinp_file() I forgot to actually
                give the mcparams along...

28.01.09        
  &&&&&&        I am now building in all the new stuff I implemented in 
                version_0.05 regarding the unformatted I/O and the 
                amr stuff.   *** THIS MAY NOT BE COMPLETE YET ***

13.02.09 &
14.02.09 &      I had problems importing the big model of Robi. I thought
15.02.09        it was because the model was too big. I then worked like
                cary to make the AMR tree more slim, which lead to the
                version version_0.05.1. But I then found out that the real
                problem was that RADMC-3D tried to allocate an array with
                dimensions freq_nr*nrcell, which is 1.4 GB large. This
                was the actual problem, and it was solved quickly.

15.02.09        Worked hard on the line module. I now think that I have
                it programmed, but I do not yet have an interface to
                the user. This still remains to be done. 

21.03.09        I continue with the camera and line modules to get the
                lines to work. Today I am trying to clean things a bit
                and make things more transparent.

28.03.09        I now realize that it is pretty bad not to have 
                the partition function available for ALL species. If
                it is not available in the form of a file, then it
                should be computed and tabulated beforehand. Otherwise
                it is going to be (a) hopelessly complex and (b) hopelessly
                slow. So I am now going to make a safety copy of the line
                module: lines_module.f90_1. And then I am going to change
                this.

                Done. And I think that now most wires are connected.

                ---> It compiles now.

                [--> radmc-3d_bk_28.03.09.zip]

04.04.09        Going through the line stuff again, to see if we are 
                complete. For instance, how can I ask RADMC-3D to make
                a channel map?


05.04.09        I am now reorganizing the program a bit: 
                  - From now on the dust tempearture, or gas tempearture,
                    or line level populations are NOT read in advance.
                    They are only read if a command from the command line
                    asks for an action that requires one of these. The test
                    to see if these data are present is simply (as of now)
                    if the corresponding arrays are allocated. 
                  - I put as a minimum for the dustdens: 1d-99. 
  ??              - I am still pondering how to do things with the camera_init.
                    Because this routine resets everything, and therefore
                    also the camera wavelengths. Maybe we have to make sure
                    to not reset the camera wavelengths? I don't know yet
                    what to do here. I think you may want to init the camera
                    only just before making a spectrum or image. That means
                    that you don't (!) want to reset everything in the camera
                    at that point. You just want to do some checks and 
                    make sure that things are set alright and allocate
                    the local arrays.
                  - I now organize that ALL read routines have an argument
                    "action" which tells if you want to just check if it is
                    read (action.eq.1) and if not, then read OR if you want
                    to throw away any previous arrays and re-read the 
                    stuff (action.eq.2).
                      ===========> STILL IN PROGRESS <===========
               
06.04.09        I continue a bit...

    &&            - In the q_cde() routine I replaced IMAG with DIMAG.
                  - Continuing with the new strategy of reading things.
                    NOT YET FINISHED.

                For now I need to stop this for a while.

09.04.09        camera_module.f90

   BUGFIX       camera_compute_one_pixel():
                The pdx can be a tiny (!) bit different from pdy, which
                leads to an error here. Now I check their difference 
                and disallow it to be larger than 1d-6 relative to their
                value.

   bugfix       readradmc.pro:
                I now included a waiting statement of the RADMC-3D
                does not respond immediately


13.04.09        
   &&&&         I am going to remove the RADMC2D backward compatibility
                io mode, because I think it is not worth it and just 
                requires more work now.

   &&           I also remove the read_dullemond_hydro(). Not useful.

16.04.09        
   &&&&&&&&     MAJOR CHANGE HERE:
                FROM NOW ON 'radmc3d spectrum' WILL HAVE A DIFFERENT MEANING.
                THE ORIGINAL MEANING IS NOW ACCESSED BY 'radmc3d sed'.

                Now the 'radmc3d spectrum' makes a spectrum with the 
                camera frequency grid.

   &&&          camera_module.f90:
                The camera_kappa_a() array now indexes the wavelength according
                to the local index (iinu in this case) instead of the SED
                global index, because I want to use camera_kappa_a also for
                the general wavelength grid.

                [---> intermediate backup: radmc-3d_backup_16.04.09.zip]

   &&&&&&&      ANOTHER MAJOR CHANGE:
                I break with the idea to have in the camera two possible
                frequency arrays. From now on the camera will ALWAYS use
                the camera_frequencies(:) array. And there will be no
                camera_inus(:) array anymore. You just have to specify 
                the camera_frequencies(:)...

            ----> Still working on it, but indeed it becomes a lot more
                  clear! The code becomes easier to understand.

19.04.09        I am continuing with making everything more transparent.
   &&&          Now I am introducing a montecarlo_frequencies(:) array
                so that also the Monte Carlo can be done completely
                independently without this 'inus' array. But the 
                Bjorkman & Wood emissivity look-up table will be always
                done on the global frequency array, and consequently
                the thermal Monte Carlo will be done based on the 
                global frequency array only! The local frequency array
                is only used for the frequency-by-frequency scattering
                Monte Carlo... It replaces the 'inus' stuff.

                Note that originally I had planned to use the B&W
                Monte Carlo to compute the isotropic scattering source 
                function, like I do in RADMC-2D. But from experience 
                with RADMC-2D I know that this gives bad photon statistics
                for short wavelengths. Instead I will force the user to
                choose either to make photon-collection spectra (a mode
                that will be included later) like what the galaxy guys
                do, or post-process the Bjorkman & Wood MC with a 
                freq-by-freq scattering Monte Carlo run. 

  MAJOR BUG:    montecarlo_module.f90
                I address dustdens with icell instead of index...!!!! MAJOR
                PROBLEM! I think I was so far simply lucky that it did not
                go badly wrong yet. I also make the same error with the
                dust temperature!!
   fixed...

   +++          I added the storage of the original kappa arrays, so that
                in case of interpolation of the opacities at precise 
                wavelengths the true opacity at high resolution is used,
                and not just a linear interpolation of the coarse grid
                global opacities. The find_dust_kappa_interpol() is now
                also adapted. Done.
                
20.04.09        Today I get the stellar source in order. This stuff was
                really only 30% done, and it irritated me. I know it is
                not too important at this very moment, but I hate making
                half-finished stuff...

   &            Removed read_starspectrum_and_info() backward compatibility
                mode. 

                Stellar source done.

21.04.09        Made small backup. 
                Now implement non-isotropic scattering in camera.

22.04.09        I found out that I used the global inu for the stellarsrc
                templates also in the monte carlo and the camera. Now I
                make a remapping on the camera frequency grid first, and
                then use that.

24.04.09        montecarlo_module.f90:
                I think I now managed, finally, to restructure the montecarlo_module.f90
                in a way that allows non-isotropic scattering. Still to do: make the
                link to the user in main.f90 and check if it is all OK in the
                camera_module.f90.

   &            I now change the camera_incl_dust to rt_incl_dust in general, because it
                is just confusing if one part of the code can include dust while the other
                part cannot. Same for lines. 

03.05.09        IMPORTANT: CONVENTION:
                I set the *positive* velocity to be away from the observer,
                i.e. reddening.

04.05.09        First time version 0.06 compiles completely. 

11.05.09        Code now is back on its feet. I can again use it like I 
                did in version 0.05 (at least tested for the ray-tracing).
                Nothing of the new modes yet tested. But I did test that 
                we can not choose any frequency really precisely, and are
                no longer restricted to the wavelength_micron.inp grid.

                [---> radmc-3d_v0.06_12.05.09.zip]
                
13.06.09        I now put lines_user_nrfreq per default to 1 instead of 100.
                In this way, if little is specified, the line image will 
                be only a single wavelength.

13.06.09        lines_module.f90:
                I change a bit the leiden database reader, so that the 
                last column of the level information is now treated as 
                a string, and read.

   ++           Added an option 'lineinfo' which makes RADMC-3D dump 
                useful information about the line it is currently
                handling. Output goes to 'lineinfo.out'.

13.06.09        lines_module.f90/rtglobal_module.f90:
                I removed do_lines_spectrum, do_lines_ppv_image etc.
                These are now irrelevant, as they are simply done by
                spectrum and image. 

27.07.09        main.f90
 bugfix              call parse_input_double ('lines_partition_temp0@',lines_partition_temp0)
                instead of
                     call parse_input_integer('lines_partition_temp0@',lines_partition_temp0)

--------------------------------------------------------------------------
                            VERSION 0.07
--------------------------------------------------------------------------

27.07.09        The goal of version 0.07 is:
                 - Introduce a user-defined module to allow special
                   compilations. This, for instance, allows the user
                   to set up a model internally, and use user-specified
                   conditions to refine the grid while making the model.
                   Another example is to introduce special boundary
                   conditions. The compilation is then done using a
                   local Makefile: the trick that I learned from the
                   PLUTO code.
                 - Get the spherical coordinates to work.
                 - Get the special AMR patch mode to work.

28.07.09
  bugfix        ioput_module.f90:
                In the array allocations you have to allocate with the
                nrcellsmax size.

29.07.09        The entire internal setup stuff seems to work very well.
                Also the local build stuff works very well.

                There is a small danger that because the grid may be
                built internally, any output files that are based on
                this grid will be meaningless. And it is not a good idea
                to require the user to not forget writing the grid file
                each time. So I now built in that when the dust_temperature
                file is written, it checks if (a) the grid has been made
                internally and (b) if the grid has not yet been written.
                If both are true then he will call write_grid_file(),
                and set the flag that the grid has now been written.
                This flag is reset at the end of each command loop.
                So with this trick the danger should be gone. 

                I also made it possible to call radmc3d with the argument
                'writegridfile', so that if you use e.g. viewimage.pro,
                which needs some information about the grid sizes, you
                can make sure that a current version of the grid file
                is available. Since writing this file can take time,
                viewimage.pro asks radmc3d to signal when it is ready
                with writing. This is done with the 'respondwhenready' 
                command line option of radmc3d. 

                I also made it possible to ask radmc3d to write out
                all the user-defined setup data. This can be useful
                for analyzing the density structure for instance. 
                This is done with 'writemodel'. 

                I added the 'cleanmodel' and 'cleanall' options.

                We 'jitter' the stars a bit in order to avoid the
                stars from falling exactly in grid cell walls.

  bugfix        amr_write_grid(): The closeing of the file was not 
                done in the case that you use a small (non-AMR) 
                grid file. The close(1) was at the wrong place.

30.07.09        
  bugfix        main.f90, stars_module.f90
                If we refine the grid, we must reestablish the locations
                of the stars, i.e. we must recompute the cell index of
                the cell in which the stars are. I therefore must split
                this off into a separate subroutine that is called after
                the user-defined model setup is complete.

  small prblm   in the examples
                I should replace the @natconst.pro with the actual
                numbers. That is more stable.

--------------------------------------------------------------------------
                            VERSION 0.08
--------------------------------------------------------------------------

31.07.09        Since the userdef_module.f90 module stuff took quite a
                bit of effort to get done properly, I decided to leave it
                there and start a new version.

                First thing to do: make a slicer. I want to be able to 
                make 1-D, 2-D and 3-D sub-blocks which are on a regular
                grid, so that it is easier to analyze.


02.08.09        
    +++         Added the subbox routines.

03.08.09        Added render3d support. All seems to work great now.

                Again, it seems that this version is so 'clean' and
                the subbox stuff works so well now, I think it is time
                to increase the version number again.

--------------------------------------------------------------------------
                            VERSION 0.09
--------------------------------------------------------------------------

04.08.09        
  BUG????       lines_module.f90:
                I find the following use of the doppler shift strange:
                   dnu   = freq(inu) - lines_nu0(iline,ispec) - &
                           lines_ray_doppler(is)*cc

05.08.09
   YES, BUG    It is indeed a bug. This is now fixed. 

               There are some other peculiarities in run_test_lines_1:
                 - It took me still a while before I finally got the 
                   Doppler shift in the run_test_lines_1 right. I think
                   that this is because I forgot to type make install(!!)
                   and typed instead just make. But I am not sure.
                 - Sometimes the line simply disappeared. I think that this
                   is because of the low spatial resolution of the original
                   model (32x32x32). I now improved it to 64x64x64 and it
                   now seems to work better. But in the current model it
                   is really on the margin. I may need to make the rotation
                   slower, or I may need to include turbulent broadening.
                 - Also in the 32x32x32 model the line disappeared at line
                   center, except very near the center of the image. I think
                   this is also a resolution effect. In the 64x64x64 model
                   this was not the case.

07.08.09       
  bugfix       dust_module.f90:
               In error code 8201 (formally 7201) I used to compare to
               freq_nr instead of dust_kappa_arrays(ispec)%nrfreq. This
               is now fixed.

               [---> radmc-3d_v0.09_14.08.09.zip]


--------------------------------------------------------------------------
                            VERSION 0.10
--------------------------------------------------------------------------

               In version 0.10 I am going to check the scattering
               Monte Carlo again. Lots still needs to be fixed...

               NOTE: Originally I did this (until 14.08.09) still in
                     version_0.09, but I decided that I wanted to
                     keep 0.09 as it is and do this scattering stuff
                     in version_0.10. 

07.08.09       Strange: The scattering MC is done at *almost* but not 
               exactly the wavelength...
               ---> Fixed. I did not use 'cc' but instead 2.9979d10.

07.08.09       I will change all scattering_mode to scattering_mode_max
               in the example models and the self test models.

10.08.09       
  bugfix       montecarlo_module.f90: 
               The starlumtot update must be inside the loop. Fixed.
  bugfix       montecarlo_module.f90:
                 if(domc) then
               must become
                 if(domc.and.(scattering_mode.gt.1)) then
               (done)

11.08.09       montecarlo_module.f90
  BUG??        It seems that the scattering MC does not:
                - Decrease energy
                - Stop when energy drops below some value

               NOT YET FIXED...

  BUG??        It also seems that when adding the scattering source, the
               absorption exp(-tauabs) is not taken into account... 

               NOT YET FIXED...

12.08.09       Working on fixing the above issues...
               Introduced mc_scat_maxtauabs variable.

14.08.09       Continued to work on this issue. 
 BUGS FIXED?   I introduced a mc_scat_energy_limit variable. I now correctly
               integrate the exp(-tau_abs) over the line segment and
               introduce the average energy over the line segment. I make
               sure that only the average energy of this line segment is
               added to the scattering source. I also make sure that the
               formula (1-exp(-dtauabs))/dtauabs is handled such that the
               limits are reproduced well. I now update the energy ("ener")
               each time and check if the energy drops below the limit.

14.08.09       I removed the line   scattering_mode_max = 9999  in the
               dust_cleanup() routine. Otherwise the setting of the 
               scattering_mode_max in the radmc.inp will not be effective.

14.08.09       Still something wrong: the inu of the monte carlo does not
               have the same meaning as that of the camera. Also, apparently
               the thermal sources don't appear in the images anymore...

  BUG FOUND    In the montecarlo_init() you must only reallocate the dust
               temperature array when using thermal monte carlo.

  fixed 1      I now fixed this problem with the temperature, I think.

  fixed 2      I now also fixed the problem with the scattering source
               function indexing, I hope. 

               It now seems to work fine, at least for the imaging!

   TODO        I still need to test if for the thermal Monte Carlo the
               scattering is correctly included. 

               [radmc-3d_v0.10_14.08.09_bk2.zip]

               Made an extra conditional on calculating the 
               mcscat_phasefunc() array in the walk_cells_thermal()
               routine...

--------------------------------------------------------------------------
                            VERSION 0.11
--------------------------------------------------------------------------

29.08.09        I now want to optimize the Monte Carlo code a bit, making
                sure that it does not waste too much time on trivial
                things.

   +++          Implementing the hunt in log(energy) (hopefully faster)

                Done. Not yet tested.

   +++          Implementing the efficient motion stuff. The idea here
                is that it is senseless to find the boundaries of the cell
                each time you move, if you know beforehand that you will
                move only a small distance compared to the size of the
                cell and where you are now.

                Wow... this was pretty difficult to do properly. The idea is
                so simple, but to implement it in the current setup of
                the algorithm was non-trivial. The main changes are
                in the walk_cells_thermal() routine. But there is also
                a slight change in the walk_full_path() routine. You can
                switch on/off this mode with params%optimized_motion.

                [--->montecarlo_module.f90_1]

   bug          I should use ispecc instead of ispec in the call to
                g = dust_gfactor(ray_inu,ispecc) in the new efficient
                motion stuff... Done.

                It appears that it is now finished. It compiles fine,
                but it has not yet been tested.

                Seems to still have some problems...


% 05.09.09        After the vacation. I first want to include the possibility
%                 to read a line list and do LTE without doing the complete
%                 level population stuff.
% 
%       ++++      If lines_nrlevels(ispec).eq.-1 then we do not read the
%                 levels separately, but instead only do LTE on the basis
%                 of a line list. This is much simpler.
% 
%    ************ WORK IN PROGRESS ***********
% 
%                 I need to think whether or not to make the pure linelist
%                 mode global or not. I think that would be best, because
%                 otherwise the code becomes really too complex. So I will
%                 force the user to choose: 
% 
%                     1) Do all line stuff with line lists (and thus with 
%                        linelist_co.inp instead of molecule_co.inp). Pros/cons:
%                         (-) Only simple LTE possible
%                         (+) Can include gas line stuff in dust temperature
%                             Monte Carlo.
%                         (+) Can use line list input files
%                     2) Do all line stuff with full molecular data. Pros/cons:
%                         (-) No dust+gas
%                         (-) No line lists readable
%                         (+) LVG, 
% 
% 
%                 or do thing with complete molecules. The linelist mode
%                 would then imply the simple LTE mode automatically. It
%                 will also not 
% 
%       POSTPONED UNTIL LATER. RESTORING ORIGINAL LINE MODULE FOR NOW.


06.09.09       I see that for isotropic scattering I determine ispecc
               while unnecessary. Is now fixed.

08.09.09       Fixed a bug in the optimized transfer: sdone must start  
               with sdone=ds value instead of 0.d0. Fixed.

08.09.09       
 !!!!!!        FOUND BLUNDER: It is not wrong, but too(!) right! I still
               do temperature interpolation of the cumulative arrays for
               finding the next random frequency... How stupid. I really
               think that this is not necessary, and it slows down the
               code considerably.

   ++++        I now introduce a "safety mode" for testing purposes in which
               these slow things are done just to be sure that we are right.
               But that is then by default off.

    &&&        I now switch off debug_check_all by default. Only if the
               safety mode is switched on it will switch this on as well.


               [radmc-3d_v0.11_08.09.09.zip]

   &&&         Since the results of the benchmark models will anyway now
               be somewhat different (because of the non-interpolation 
               in the temperature) I decide to also change this small
               thing marked as "Note: Tiny increased efficiency" in the
               montecarlo module.

   BUGFIX      I forgot that we must adjust ds to fr * ds. So the 
               optimized motion was never active... Now fixed.


 STRANGE!!!?   It seems now that the optimized transfer makes things
               significantly SLOWER!! Really strange....!!



......................... SUMMARY UNTIL NOW: ...............................
In this version (0.11) the following main things have been done:

 * Simple speed ups:
   - The debug_checkall is now by default 0
   - The temperature interpolation in the finding of a new frequency is
     switched off by default now.
   - The Makefile is now with -O2 and without -fbounds-check

 * New mode: An optimized movement thingie, which prevents the requirement
   of always having to call the find_next_location_cart(). 

 * I precalculated absorb * energy / alpha_a_tot (calling it dummy) so
   that for the optimized movement of photons the calculation of
   dum = absorb * (taupath-tau) * energy / alpha_a_tot can be shortened
   to dum = dummy * (taupath-tau).
.............................................................................


09.09.09       Add some diagnostics to the setup.

10.09.09       OK, I now realize what could be (partly) responsible for
               the weird behavior. The thing is that normally the new
               taupath is randomly drawn at the start of the next loop.
               before the walk_cells_thermal and the start of the next
               loop there is still this random direction thing. When
               the next taupath is already determined in the walk_cells
               routine, then this is done before the random direction
               thing. 

   &&          From now on the walk_cells_thermal() routine will give
               the next taupath...

   BUG!!       Of course! If I change the frequency of the photon,
               I also must change the opacity... I do that of course
               for the case of the normal transport, but not for the
               optimized transport. I am so stupid ;-).

               Fixed...

  ????         But still the number of events in the case of optmized
               transfer is not the same as in the case of unoptimized
               transfer.

  BUGG!!!      OK, also the absorption event has to be done beforehand,
               to check if we don't exceed the dsmax. This opens yet 
               another problem: if we exceed dsmax, we will return and
               we will do things "normally". But we should then not 
               redo the absorption event... It becomes more and more
               complex... It seems that also the absorption and 
               scattering stuff should be entirely embedded into the
               walk_cells_thermal routine...

11.09.09       Pfew... Now it finally seems to work. Indeed, I now
               went back to the -taupath trick, and included the 
               discrete events in the if(taupath.gt.0.d0) check.
               Now it seems to work. 

               [radmc-3d_v0.11_11.09.09.zip]


11.09.09       ********* IDEA *********

               I think that I might have come up with an alternative
               to the Min et al. method of accelerated motion. The 
               idea is that you can artificially limit the opacity
               to some maximum, which depends on the location, and make 
               a larger step instead.

               ... (a photon absorption event takes place)
               [Determine the ispec which did the absorption]
               kappa_max = tau_accel / ( rhodust(ispec)*dsmax + 1d-99 )
                ==============> I think this is not correct! <===========
               ...
               [here reduce the chance of randomly choosing inu in these bins]
               ...
               if(kappa_nu.gt.kappa_max) then
                  ds_used       = ds * sqrt(kappa_nu/kappa_max)
                  dtaupath_used = dtaupath * kappa_nu/kappa_max
               else
                  ds_used       = ds
                  dtaupath_used = dtaupath
               endif

               Note that in the above algorithm I made it for multiple
               species with different temperatures. There is still an
               error in the algorithm... Must use the total opacity
               of all species added up.

               The main limiter to the speed, I suspect, is the adaption
               of the cumulative arrays for the random inu, because this
               method works by lowering the chance that you randomly roll
               an inu with high opacity, but inus with low opacity will
               have the same chance. How to do this without having to
               make an entire do inu=1,freq_nr loop remains to be 
               figured out. For the rest, I think, that the method 
               could work.

               (not yet implemented)

               Maybe we should just be bold for the moment and just 
               add all cumulative arrays together, weighted by the
               enerpart. We can then use the total opacity to do the
               cutting-off. Hmm, but that also requires a lot of loops.



--------------------------------------------------------------------------
                            VERSION 0.12
--------------------------------------------------------------------------

17.09.09       Thomas and Kees now build in a new module for gas
               continuum opacities and emission:

                  gascontinuum_module.f90

               *** IN PROGRESS, NEARLY DONE IMPLEMENTING FREE-FREE ***


21.09.09       It compiles. So it seems to have been built in. But I have
               not yet tested it in any way. 

     ++        Added the possibility to switch off/on various processes
               also in the radmc.inp, not only on the command-line. 

     +++       Added a new method of specifying wavelength points of a 
               spectrum: the command line options: lambdarange and nlam.
               
22.09.09
     ++        Added NAN check for dust temperature
     ++        Added check to avoid NANs at locations that have not been
               visited by photons.

     !!        If the userdef module sets the density to 0, then make sure
               to set it to 1D-99. Otherwise the temperature will become
               zero.

     &         I removed the dusttemp(:,:) = 0.d0 in the montecarlo_init()
               because this is already done in the subroutine
               do_monte_carlo_bjorkmanwood().

     ++        I included a check on input data:
               rtglobal_check_inputdata().

     &         In postprocess_grid_for_use(renew) I now did a switch
               for grid type.

     +++       More diagnostics about the grid refinement in the output.

               [---> radmc-3d_v0.12_22.09.09.zip]

25.09.09       
  bugfix       gascontinuum_module.f90:

                 if(index.lt.0) return  --->  if(index.lt.1) return



--------------------------------------------------------------------------
                            VERSION 0.14
--------------------------------------------------------------------------

27.09.09       Working on spherical coordinates right now.
               WORK IN PROGRESS

   ++          readradmc.pro:
               Added keyword "options" to makeimage. This should be an
               array of strings to pass on to RADMC-3D.

07.10.09       
  bugfix       ioput_module.f90
               The unformatted output of the dust temperature was broken.
               First it was simply switched off, and then there was not
               form='unformatted' in the open statement.

13.10.09       NOTES FROM DISCUSSION WITH RAHUL SHETTY:
                - Button of spectrum in viewimage broken
                  ---> Fixed! (20.10.09)
                - 

20.10.09       In the camera module the line mode for spectrum was switched
               off.

20.10.09

 **** MAJOR CHANGE! ****
 For consistency we now do the switching on/off of dust and/or lines in a
 different way:

     Per default the code will simply look for the dustopac.inp file and
     the lines.inp file. If the dustopac.inp file is found it will automatically
     switch on the dust unless nodust is explicitly stated either in the 
     radmc.inp or on the command line. Same for lines.

 This also means that if you do SED, and if you have lines, then if you
 have bad luck you may hit a rare line and get a huge hump. But this is 
 actually good: if you have long line lists, then this would be like doing
 opacity sampling. The user can always switch off the lines if he/she wants
 to be sure not to accidently hit a line with the SED wavelengths.

               The safe thing for the user to do is now to always 
               set the incl_dust or incl_lines in the radmc.inp...
               But it is now no longer necessary to include /incllines
               in the viewimage. That was silly anyway.

***************************************************************
******** SO FAR I DID NOT IMPLEMENT THIS CHANGE !!!!! *********
***************************************************************

02.11.09       
   &&&&&&      montecarlo_module.f90:
               *********** I CHANGE BACK TO ORIGINAL NON-OPT STYLE **********

               The optimized motion stuff is still a bit scary. I am 
               not sure how good it is. Even if I switch it off, the
               main structure of the photon walk stuff is different,
               so that the self test is not passed. Presumably this is
               simply because the random number generator will divert,
               so that would be nothing serious. But I do not want to
               risk anything. 

               So I am going to put the switch for the optimized 
               motion higher up in the subroutine hierarchy. But first
               
               << STILL WORKING ON THIS >>

12.11.09       Continuing on this.

  &&&&         DONE: I have reimplemented the old style monte carlo 
                     photon movement of version_0.10, IFF the 
                     params%optimized_motion.eq..false. . So the
                     new style will only take effect if the optimized
                     motion is switched on.

               However, somehow the code still does not pass the selftest.

15.11.09       I found the reason why the code did not pass the self test.
               The reason was that in the routine walk_cells_thermal()
               there is a place where it will figure out off which dust
               grain species the scattering happened. This is only 
               necessary if the scattering is anisotropic. In the new
               version I put in a check if this is required. But that
               meant that there was one less random number taken...

  !!!!!!       The way I will fix this is to add a random number picking
               even if there is no need for it. It will be added in
               walk_cells_thermal() and walk_cells_scat():               

                  rn = ran2(iseed)   ! NOTE: This is not necessary, but is just
                                     !       there to pass the selftest. 
                                     !       See notes 15.11.09 in Radmc_3D_LOG.txt

               It is a bit slower, but isotropic scattering is anyway not
               very realistic I think this should not be a problem. And
               later, for optimized transfer, I will anyway use the other
               walk_cells_thermal_opt(). Only for the scattering MC it
               may be nice to improve this later. 

               Hmm... It STILL does not pass the selftest...

               It seems to be much more subtle. At some point the alpha_tot
               is different between versions 0.10 and 0.14... The rest is
               the same: ray_cart_x,y,z as well as ray_index and ds.

               Ah: I see that at that point the ray_inu is 123 in v0.10
               and 124 in v0.14. This seems to point to the different ways
               in which the inu is chosen. True, in the new version we use
               the log tables. 

               I am puzzling further. It seems that the dusttemp is not
               perfectly identical in both cases...

               It seems to be that between 0.10 and 0.14 I changed the 
               default setting of mcparams%intplt to 0... Let's see if
               this is the one that could fix it...

   !!!!!       YES, this is it! This is clearly the reason why the selftest
               did not work. 

   &&&         So this is what I intend to do: 
                - Keep the intplt by default to 1, but allow the user to
                  set it to 0. 
                - I will in fact RENAME intplt to iranfreqmode!!!
                - This is what I will do in the selftest run_simple_1* etc. 
                - I will then also include a new model: 
                  run_simple_1_irandfreqmode1.

   SUMMARY:    So to recapitulate:
                - By default we now have the original way of doing the
                  Monte Carlo photon propagation. The optimized motion is
                  now by default switched off, and also the code changes
                  that were necessary for that method will now no longer
                  be used. So we are now by default backward-compatible,
                  EXCEPT for the iranfreqmode (see below).
                - iranfreqmode (formally known as intplt) is now by default
                  set to 0. This means that NO linear interpolation in the
                  temperature is done when a new inu is picked in the 
                  subroutine montecarlo_module.f90/pick_randomfreq_db().
                  In the selftest the irandfreqmode is explicitly set to
                  1 to be consistent with previous models.
                - But the ifast remains 0 by default.
                - I implemented a *useless* ran2() call in the routines
                  walk_cells_termal() and walk_cells_scat() just to be
                  consistent with previous versions, so that the selftests
                  will go perfect. It is only slower-than-necessary if you
                  have isotropic scattering. Since that is not very realistic
                  anyway, it should not be a major problem.

                  
               Now the self tests are succesful!!!

               ---> radmc-3d_v0.14_15.11.09_full.zip

--------------------------------------------------------------------------
                            VERSION 0.15
--------------------------------------------------------------------------

16.11.09       Now I continue to work on the spherical coordinates part.
               Partly I did this while sitting in the car half-way the
               Koenigstuhl in the dark, waiting for the ADAC car coming 
               to help me with my fallen-off exhaust pipe ;-).

   bug?        ioput_module.f90:
               I think I found a bug there where I already made an earlier
               bugfix: bugfix 28.07.09. I still allocate the arrays with
               nrcells instead of nrcellsmax. 

               I do not yet fix this, because I am not sure if it is a bug.
               I mark it with "Bug? 16.11.09"

               Further I have been fixing a lot of work in progress things
               related to the spherical coordinates. This includes also
               things in the amr_module and amrray_module, as well as in
               the camera_module and ioput_module. The subbox routine is
               now able to handle spherical coordinates. The cell volume
               is now computed also for spherical coordinates. The base
               grid is checked for monotonic increasing values. 

               I also implemented a decent computation of the celldxmin
               value. This was a difficult matter. I now included a crude
               treatment of the projections of the cells onto the plane of
               the observer. That is, however, a rather heavy calculation
               and I am not sure if it could be done better.

               I did also go partly through the huge find_next_crossing_spher
               routine, but that is still work in progress.

               All in all I think that I have made substantial progress
               with the spherical coordinates!

               [--> radmc-3d_v0.15_16.11.09_bk.zip]


17.11.09       I removed the check_grid() routine and moved the content into
               the postprocess_grid_for_use(renew) routine.


22.11.09       
  BUG!!        Rahul Shetty found a bug in the line module. When counting
               the active lines in the lines_find_active_lines_levels()
               I count things multiple times when I do a loop over multiple
               frequencies.

               I think I now fixed it. Marked with BUGFIX 22.11.09.
               I basically swapped the two loops and introduced the 
               notdone flag which I put to .false. as soon as an active
               line is identified. I hope this works...

30.11.09       Thinking further about the spherical coordinates. In the
               last few days I fixed and debugged much of the amrray
               stuff for the spherical coordinates, but I did so outside
               the current code (I did it in the test_spher/ directory).
               One thing I realize which is really important:

                 - During the ray-tracing we should only really assume
                   that we arrived if we are starting from vacuum and
                   end in vacuum. Just exiting the grid is not enough
                   as a ray may re-enter the grid. In principle this
                   should automatically work with the "arrived" flag,
                   because that is only set to .true. if indeed we
                   stay in vacuum.

01.12.09       In principle the spherical coordinates mode should now
               work. I tested the amrray_module.f90 with the spherical
               coordinates in the test_spher/ directory, and then copied
               both amr_module.f90 and amrray_module.f90 into the current
               src/. I also included in that amr_read_grid() will check
               whether the theta and phi coordinates appear to want to
               be pi/2, pi or 2*pi but are not exactly. It will catch
               this and adjust the coordinates. Also the cellvolume will
               now be calculated properly for the spherical coordinates.
               And I computed the default size of the image now correctly.
               Also the subbox stuff should work in principle.

    bugfix     In the subbox defaul values there are two bugs: instead
               of amr_grid_nx+1 it says amr_grid_nx, and instead of
               amr_grid_ny or amr_grid_nz it says amr_grid_nx. Fixed
               it.

               I would not know really what else has to be done. But I 
               have not yet tested it...
              
               [--> radmc-3d_v0.15_01.12.09_bk.zip]

01.12.09       Further with the code. Some minor improvements. For instance:
               Now the mirroring mode is automatically switched on if 
               max(theta)==pi/2. Also some checks are switched off if 
               in lower dimensional mode.

      bug      Found a small bug: in 1-D you should not use the topquadrant
               flag nor the crossequator flag. Fixed.

               Bingo! The first 1D model works!

    ++         And I now also improved the readradmc.pro.

               [--> radmc-3d_v0.15_01.12.09.zip]

02.12.09       1D test = OK

               I compared the results from RADMC-3D in 1-D spherical mode
               to transphere, for mild optical depths (about 4 events per
               photon on average). The results are in:

                 run_spher1d_2/               for RADMC-3D
                 run_spher1d_2_trsph/         for TRANSPHERE

               The comparison of the temperatures is plotted in 

                 run_spher1d_2/compare_temp.ps

               They agree very well! So I am very happy with the results!
               In fact, considering the low spatial resolution we are 
               working with it is quite amazing.

               Now also the viewimage.pro works fine!

               So it seems that we can conclude that in 1-D spherical
               coordinates the code works!

               [--> radmc-3d_v0.15_02.12.09.zip]

               Now let's see if we can do something 2-D...

 MAJOR BUG     camera_module.f90
               I found a major bug in the camera routine for setting up
               the rays. It does not show up in boxes  (-1:1,-1:1,-1:1), but
               it would go badly wrong for boxes (0:1,0:1,0:1).

               ---> Fixed. I also retrospectively fixed this in version_0.14.
                    But older versions are not fixed!

               Now I am working on the 2-D spherical coordinate stuff. That
               is a bit trickier. It seems to work partly, but there are
               still weird things. 

        &&     main.f90:
               I now switched the self-checking back on by default.

  bugfixes     I noticed that theta_t2 was simply wrong. Fixed.
               I noticed that the theta_r1,r2,p1,p2,t2 were not mirrored
               if necessary. Fixed.

               But this does not fix the problem. I still get a crash when
               imaging the disk at i=120 deg.

 bug 0-ed in?  It appears that the remaning problem with the theta-crossings
               of the grid lies somehow in the choice of which is the ds
               solutions we should take. I have to think more about this.

               Found a problem with theta2_sgn: was theta1_sgn where it 
               should have been theta2_sgn.

               Also: The thetagrid_cross_equator should also be .true. if
                     we have mirror symmetry. 
               Also: The theta2_sgn should also be -1 if
                     we have mirror symmetry. 

               All fixed...

               Wow, looks already a lot better... 

               [--> amrray_module.f90_1]

               But still I now bumped into stop 8329... This may be just
               a precision problem. Hmm, maybe I have to make the "tiny"
               number a bit larger. But not too much. Is the s00 working
               properly? It should avoid this kind of problems actually.

    ++         I also now implemented a check to assure that the grid
               spacing is always more than 4*small.

    ++         In checking the unit vector length I now replaced 1d-10
               with tiny.

               I checked that the s00 trick seems to work well. For instance,
               when I get the stop 8329 I find that ds_r1/r = 84.32 and
               s00/r = 83.70. So that means that indeed the quadratic
               equation was done on just the difference. That is exactly
               what I meant to happen.

               But I think I now understand what is going on: While the 
               s00 shift trick may avoid catastrophic failure of the
               equations, it does not prevent the simple *linear* loss
               of accuracy. If you are at 100 AU and wish to hit a sphere
               of 1 AU, then even a linear error of 1% will kill you. Or
               in other words: for each decade increase in ratio r_out/r_in
               of the grid you lose 1 digit accuracy in your computation of
               r. Since you have 16 digits to start with, losing 4 or 5
               is not a big problem, unless you have grid refinement that
               is extremely fine. 

     +++       So to avoid this let us make a small correction in the
               position if necessary. But only for the crossing with the
               inner radius. For the crossing with the theta or phi 
               edges we will not need it because it will not happen in 
               practice that the grid in theta or phi will be so finely
               spaced (except perhaps near the equatorial plane, but there
               you will not have a crossing of a ray from outside).

               I increase the self-test tolerance to 1D-5, instead of
               tiny, so that only if things go badly wrong we will get
               alarm.

               ---> It seems to work!!! At least for the case without
                    mirror symmetry. This is great!

               Grr... When I increase the spatial resolution of the 
               model we again run into an out-of-cell error... But
               let us stop here anyway and save:

               [--> radmc-3d_v0.15_02.12.09_b.zip]
               
03.12.09       
  check this:  In the line lte population, check if the ground state is
               properly used... See comment.


03.12.09       I think I know what causes the problem with the out-of-cell
               error. The problem is that the rays coming from the star
               are moving radially outward. If they happen to move very
               close to a theta-line, and your direction is also parallel
               to the theta line, then you may get in trouble.

04.12.09       amrray_module.f90

  bug          While implementing the Taylor expansion for the quadratic
               equations for the theta-grid crossings I noticed that my
               original formula for the ds_try for the parallel case was
               wrong: a minus sign was wrong. Maybe this is part of the
               problem?

   &&&&        Anyway, I improved the theta-grid crossing search a lot
               by implementing a Taylor expansion if abs(4*pa*pc/pb^2)
               becomes too small and the sign of pb is correct for the
               case at hand.

               ---> Wow, it seems to work!!!

               [--> radmc-3d_v0.15_04.12.09.zip]

   ++          Added the run_spher1d_2 and run_spher2d_2 to the 
               selftest benchmark models.

  bug          dust.f90
               I fixed a bug in which eps is not perfectly within [0,1].

  BUG          I forgot to put igrid_mirror to 1 if we use mirroring.
               ???

  bug          ioput_module.f90
               I checked the monotonicity of the grid before checking if
               we indeed use AMR grid. Fixed.

  BUG          When making an image with scattering, somehow the x,y,z
               are taken to be r,theta,phi, and this leads to the 
               out-of-cell error... The reason is that the thermal 
               emission gives a location of the starting point of the
               photon. Here I did not do the spherical coordinate stuff
               yet. ---> Fixed.

               Now the imaging seems to work again! 

  TEST         run_disk_mindul_mdust_1d-6_nphot_1d7/
               I tested the current code against the Min & Dullemond
               benchmark test for the low disk mass. That seems to
               work fine!

               ---> CONCLUSION: We seem to be having a succesful 
                                implementation of spherical coordinates!
                                Of course, small problems will appear,
                                but for now I think we can be really
                                very satisfied!!!

 ** TODO **    Check if you do the thermal source of photons correctly
               in the montescat subroutine! I think it should be fine, 
               but we must be sure.

               [--> radmc-3d_v0.15_04.12.09_b.zip]

05.12.09       
  bug          Before doing the subbox for dust density or temperature
               you must read_dustdata(1)... Fixed.

               ----> Will also fix this in version_14

   NOTE:       For line transfer with Doppler shift we must be careful
               when we use axial symmetry or spherical symmetry! We must
               then define how the velocity vector is defined...

--------------------------------------------------------------------------
                          VERSION 0.16
--------------------------------------------------------------------------

06.12.09       Since the spherical coordinates seem to work well, I leave
               version 0.15 for what it is now.

               In version 0.16 I will add new possibilities to the code.
               For instance, the possibility to compute the mean intensity
               of the radiation field everywhere at a given set of
               wavelengths.


07.12.09
  MAJOR BUG    If you use more than one stars, then the choice of which 
               star is used may be wrong!!!!
               ----> Fixed, I think...
                     Added star_lumcum array to star_module.f90
                     Modified montecarlo_module.f90 to include 
                     the better choice of istar.
               ====> Also now fixed in versions 0.15 and 0.14...
              
08.12.09       
      ++++     I now finished the mcmono mode! Including the writing
               of the mean intensity file. Not yet tested...

               [---> radmc-3d_v0.16_08.12.09.zip]

               For now I leave version 0.16, because the implementation
               of the spheres (below) turned out to be far from trivial!



--------------------------------------------------------------------------
                          VERSION 0.17
--------------------------------------------------------------------------

08.12.09       In this version I now want to implement the finite sizes
               of stars. 

    ....       Working on finite star mode. Not yet ready.

               This is quite a big thing... Much more involved than I
               thought. It may require the use of an array of integers,
               with one integer for each cell, to help the finder of
               crossings with checking for crossings with spheres.

........................................................................
   BUG?        One major question: So far I have not done any refinement
               of the grid on-the-fly. But I do not seem to really using
               nrcellmax instead of nrcells when allocating arrays. Is 
               this OK??
........................................................................

               For now I simply ignore this problem, since we do not
               do on-the-fly refinement anyway...

               OK, I finished making the routine:

                   amrray_install_spheres()

               but still much to do...

               ===> STILL WORK IN PROGRESS...


10.12.09       Things to do for the spheres:

                - Implement sphere-crossing outside of grid
                - Implement sphere-crossing inside of grid
                - Make sure that the stuff with ray_dsend is done well
                - Update the xyz correctly
                - Implement that a photon can jump to far-away cell
                  or can simply continue to walk within a sphere.
                - In MC: Remove cell if it hits a sphere
                - In Camera: move through a sphere, but adapt intensity

    !!!        Then another thing: We can speed up the calculation of
               the crossings in the spherical coordinates much if we
               check if there is any chance in the first place to hit
               a wall.

               It compiles...

               Still to do now:

                - Implement that a photon can jump to far-away cell
                  or can simply continue to walk within a sphere.
                - In MC: Remove cell if it hits a sphere
                - In Camera: move through a sphere, but adapt intensity

               [--> radmc-3d_v0.17_10.12.09_bk.zip]

10.12.09       
     &&&&      montecarlo_module.f90:
               I am going to remove the idestroy integer entirely, and
               instead have a global mc_photon_destroyed logical.

     Note      montecarlo_module.f90:
               In the scattering monte carlo I should have used 
               mc_photon_destroyed = .true. instead of arrived = .true.
               if the photon is extinct. But for this mode it really
               does not matter, so I keep it. I will mark it, however,
               for possible future reference.

               I implemented a check that the spheres don't overlap.

               Still to do now:

                - Implement that a photon can jump to far-away cell
                  or can simply continue to walk within a sphere.
                - In Camera: move through a sphere, but adapt intensity

11.12.09       This is now all done.

               Now we still have to ensure that the flux from the star
               is picked up in any image, no matter how low the resolution
               of the image is. I have an idea how to do this: you basically
               continue the sub-pixeling until you have all spheres in that
               pixel fully inside the pixel. Then you can simply add the
               star in a similar way as the point source star, but this
               time with the removal of a bit of the pixel surface area.
               If a star remains crossing the pixel boundary, then we 
               zoom-in until, say, 1/10 of the radius. 
               
               The main problem I see is that if we make images with
               an even number of pixels, then if the star is located
               at the center, then it will always remain on the pixel
               boundary, and thus we would be forced to sub-pixel all
               the way down, which is costly. 

--> Write in the manual that the sub-pixeling only works well if the
    AMR is done successively, and not abruptly.

               [--> radmc-3d_v0.17_11.12.09_bk.zip]

12.12.09       Working on implementation of external source...

   ++++        I activated the external sources
   ++++        I activated the smooth stellar sources
               Both are compiled but not yet tested. 

               I added information in the manual about these things.

               Also fixed a small bug: after making a spectrum, you 
               must reset the defaults of the camera_image_nx,ny.
               This is too small a 'bug' to actually worry about.

               Tested the multi-wavelength images. Seems to work.
               Added information about this in the manual. 

   !!!         General major additions and improvements to the manual.

               [--> radmc-3d_v0.17_12.12.09.zip]

               KEEP IN MIND: The flux conservation with spheres is
               not yet guaranteed.

13.12.09       Viewimage.pro: Added imol, iline and vkms.

  bugfix       Also fixed some problems related to the default settings
               of lines_user_widthkms and lines_user_nrfreq.

   BUG         Somehow the CO 1-0 works fine, but the CO 2-1 crashes...
  BUG FIXED    I had the gdeg an integer!! That is wrong!! The ratio of
               integers can easily be wrong...

               ----> Fixed. Also fixed in versions 0.14, 0.15 and 0.16.
               

  SLOWDOWN     Note that at each point ALL level populations are computed.
               Not only those that are necessary. This slows down the 
               code tremendously!

.........................................................................
  STRANGE      It seems that the selftest for the run_spher2d_2/ model 
               fails when the code is compiled without -O2. I checked
               the differences in the temperatures: they are really
               minimal: 0.001 degrees Kelvin on a scale of a few        
               hundred Kelvin, and only on a few spots. But still this
               is strange... Apparently there is some variable not always
               well set or so. I must check this out, because it might be
               the tip of an iceberg. On the other hand: maybe not. 
               ----> For now this is not checked...

14.12.09       I now checked this: It turns out that the line:

                 amrray_branch_costsq1(idx) = cos(theta1)**2

               gives different results depending on -O2 or not. It gets
               even stranger:

                 - If you put a check right after this line, then both
                   results are the same, AND the results of the entire
                   code are the same; just by adding a write statement!

                 - If you add 0.77015113038694138 + 0.22984886961305856
                   you get 1.000000000000000000, and if you subtract 1.d0
                   you get 0.000000000000000000. But if you look closely
                   you see that it should give a tiny residu. The real
                   value of the second number (the cos^2) is in fact
                   0.22984886961305862. Indeed, that should indeed add
                   up to 1.d0. But even the slightly wrong number adds
                   up to 1.d0 with -O2. 

                 - But if you compute 1.d0 - 0.77015113038694138 then you
                   get the correct value 0.22984886961305862, EVEN WITH
                   -O2 ! Note that all of this is simple addition and
                   subtraction, nothing fancy... WEIRD!

               My conclusion is that with -O2 the precision is not really
               perfectly double precision. Something is weird. Whether
               this is a bug in the code or just something strange of
               the optimization, I do not know. 

               [----> radmc3d_v0.17_debug_14.12.09.zip]

               ===> I will fix this by computing not the cos()**2 but
                    1.d0-sin()**2...
               ---> Done! Now the self-test is passed also if we switch
                    on/off the -O2. 
.........................................................................

   bug         I implemented the ,scatsrc,meanint keywords in the 
               do_monte_carlo_scattering() subroutine. But I seem to have 
               forgotten to actually set these!

14.12.09
  bug          amrray_module.f90:
               In the spheres detection in the spherical coordinates:
               don't put idir=0, but icross=0. But in the cartesian
               coordinates it should be kept idir=0.
               ---> Fixed...

               [--> radmc-3d_v0.17_14.12.09.zip]

15.12.09       montecarlo_module.f90
   bug         The random launching direction should be:
                rn            = ran2(iseed)
                ray_cart_dirx = sqrt(rn)
                dum           = twopi*ran2(iseed)
                rn            = sqrt(1.d0-rn)
                ray_cart_diry = rn*cos(dum)
                ray_cart_dirz = rn*sin(dum)
                call montecarlo_rotatevec(ray_cart_dirx,ray_cart_diry,ray_cart_dirz, &
                               -pdirx,-pdiry,-pdirz)
               So there must be the (1.d0-rn)* factor there!
               ---> Fixed.

   bug         I never switched on the sphere star mode, because I 
               never called the routine amrray_install_spheres().
               ---> Fixed.

   bug         I wanted to reset the camera_image_nx = 100 because 
               during the spectrum-taking this is set to 1, which might
               make the image-taking afterward problematic. But this is
               dangerous, because in the child-mode it has to remember
               this number. 
               ---> Fixed.

   bug         In installing the spheres in amrray_module.f90, I should
               still use the amr_coordsystem, instead of the amrray_icoord.
               ---> Fixed.

               Now it seems to work, to have the star as a sphere. At 
               least it works for spherical coordinates, with the star
               at the center. 

               ** BUT STILL FLUX CONSERVATION IS NOT GUARANTEED **

               [--> radmc-3d_v0.17_15.12.09.zip]

15.12.09       
   +           Re-installed the possibility to switch off the star, even
               if we have spheres.

               Now the only remaining issue is the flux conservation.
               Right now the star is not visible at low resolution
               images. So we need to:
                 - Implement a quick fix for when no flux conservation
                   is strictly required. But of course we do want to 
                   have at least a star dot in the center
                 - Implement full-fledged flux conservation also for
                   the star if flux conservation mode is switched on.

               This remains still to do...

               [--> radmc-3d_v0.17_15.12.09_b.zip]

16.12.09       Continuing...

               Refinement criterion pdx --> max(pdx,pdy).

               After some more debugging, particularly noticing that I
               am not allowed to change istar in the recursive subroutine,
               it now seems to work!!!

   !!!!        ====> At least for a central star in spherical coordinates
                     the recursive sub-pixeling for the star (treated as
                     a sphere) now seems to work!!

               [--> radmc-3d_v0.17_16.12.09.zip]

--------------------------------------------------------------------------
                          VERSION 0.18
--------------------------------------------------------------------------

16.12.09       Here I want to implement the layered-style AMR! This is a
               major simplification of the AMR input structure, allowing
               much easier use of the AMR refinement in case of simple
               problems such as refinement around a planet in a
               protoplanetary disk or such. This is what I used to call
               "patches", but which I simply call "layers" now.

               *** in progress ***

19.12.09       Further with the layers. I now seem to have finished this.
               It compiles and all the input and output stuff has been
               modified to accomodate this possibility. 

  bug?         It seems that the unformatted stuff for the microturbulence
               is not correct. Check this...

21.12.09       
   !!!         It now seems to work, the layered-AMR.
   !!!         Also the manual is again updated, including 
               XFIG diagrams of AMR-style grids.

               [--> radmc-3d_v0.18_21.12.09.zip]

22.12.09       I now improved the readradmc.pro to be able to read the
               layers.

               Updated the manual to described the read_data() stuff
               including the layered AMR stuff.

               [--> radmc-3d_v0.18_22.12.09.zip]

22.12.09       
  NOTE:        I realize that the anisotropic scattering mode does not
               work properly for spherical coordinates with axial or 
               spherical symmetry (2-D or 1-D). The reason is that 
               with such a symmetry a single cell would consist of
               locations with distinctly different angle toward the
               observer. 

    ++         I added a check in the camera_module.f90 for that.

    bug        In the 3-D spherical coordinates mode I forgot to set the
               zcyclic=.true. in case phi goes from 0 to twopi.
               ---> Fixed.

    BUG        Somehow the 3-D spherical coordinates test crashes...
               Not yet identified why. STOP 1132.

   problem?    I now read on the internet that a declared pointer cannot
               be queried if it is associated or not. This might have been
               the problem with the error I got with the layers!

   BUG FOUND   The above stop 1132 bug is found: if the flag crossequator is
               .true., then this does not yet mean that the equator is indeed
               crossed. Only if icross.eq.4 or .eq.3 (depending on whether
               you are in the top or bottom quadrant).
               ---> Fixed.

25.12.09       In the self-checking if the point is outside the cell, the
               periodicity of phi was not accounted for properly.
               ---> Fixed.
               Note that this also must be fixed at the check at the 
               start of the find_next_crossing.
               ---> Fixed.

               Now it seems to work for 3-D spherical coordinates again.

               But somehow the selftest for 2-D spherical coordinats
               fails...

               ---> Fixed: The if(.not.crossequator) then clause is not
                           necessary. I removed it and it passed the self
                           test again.

               [--> radmc-3d_v0.18_25.12.09.zip]

               It seems to work well. I made a 3-D blobby AGN torus model
               which seems to work. So let us declare this the final 
               state of version 0.18. 

--------------------------------------------------------------------------
                            VERSION 0.19
--------------------------------------------------------------------------


27.12.09       amr_module.f90
               I now start with the memory-improvement of the AMR module...

               Here are the things I need to do:
                - Remove the unnecessary q
                  ---> DONE
                - Instead of having children always, I make a new structure
                  containing 2x2x2 pointers, and allocate that only for
                  a branch...
                  ---> DONE

               And it seems to work!! Selftest completed succesfully.

               [--> radmc-3d_v0.19_27.12.09_a.zip]

               Next:
                - Add xc and xi 1-D arrays, and check if they are 
                  always identical to the original cell-based ones.
                  ---> DONE

***************************************************** 
               amr_module.f90:
   &&&!!!      Making base level the level 0!! This is better in agreement
               with the layers. 
               AOUPS: This almost went wrong!! I forgot that the level is
               actually used in the camera. Perhaps that was also the reason
               why gfortran crashed an hour ago: 2^-1 is not an integer
               operation!
   WOW!        I only found this due to the self-test!!! I love this self-test
               things!
               I also found that things had to be changed in the ioput_module.
               I also changed the +1 in going from nr of levels in the layers
                   to the levelmax variable. 
***************************************************** 

               Now it passes the selftest again. And the checks that the 
               1-D arrays are identical to the cell-based xi and xc values
               has also been done and tested.

               [--> radmc-3d_v0.19_27.12.09_b.zip]

               Now we must replace all references to %xi and %xc everywhere.
               This is a big task...
               ---> DONE

               And tested with self-test. All things work, even the spherical
               coordinates!!!

               [--> radmc-3d_v0.19_27.12.09_c.zip]

  Bug found    amrray_module.f90:
               I forgot apparently to deallocate the amrray_branch_cosp1
               arrays and such... Will do now better.

               Finally, we must put also all the cos and sin tables into
               1-D arrays.
               ---> DONE

               And tested with self-test. All things work, even the spherical
               coordinates!!!
               
               [--> radmc-3d_v0.19_27.12.09_d.zip]
               
               Also made a full version, with the self-test stuff:
               [--> radmc-3d_v0.19_27.12.09_full.zip]

--------------------------------------------------------------------------
                            VERSION 0.20
--------------------------------------------------------------------------

28.12.09       Next on the to-do-list:
                - Allow setting of the nphot_scat
                  --> Done
                - Make the local perspective stuff work
                - Make the movie-making work

   &&          I introduced different nphot for scattering and mono:
                 nphot_scat and nphot_mono.


               Note that camera_image_halfsize_x,y is the image size,
               which is in cm for observer at infinity and in radian
               for local observer. We must thus do two things:
                 - In the spectrum computation we must take this into
                   account
                   ---> For now we simply switch off the spectrum mode
                        for local observers.
                 - In the image we must somehow make clear that this is
                   an image at infinity or an image from a local observer.
                   ---> Done: format number = 2 means using radian as size.

               I included self-checks that the image size things are done
               correctly. Clearly radians are order unity while image sizes
               (being in cm) must be >>>1. Easy to check.

               It seems that I have now much of the local observer stuff
               built in, i.e. activated this and made it possible for the
               user to set the variables and included a lot of checks.

               But I still have to look at the scattering monte carlo
               stuff... 
               Done...

               OK, tried it, but the code hangs... No idea why.
               It is too late now to continue this. Continuing tomorrow.

               Could not sleep, so tried to fix this. Yes, it now works!!
               I had just forgotten to put arrived=.true. at the right
               spot(s).

               [--> radmc-3d_v0.20_28.12.09.zip]


29.12.09       

   &&&&&       I changed the compilation order of the userdef module 
               and the camera module. They are now swapped!!! This may
               have consequences for models that use a user-defined local
               compilation, because then their compilation order is not
               right.

   ++++        Also I added a new subroutine in the userdef module:
               userdef_compute_levelpop(). This allows the user to make
               his/her own calculation of the level populations on the
               fly while the images are made. 

               ----> It compiles, and all self tests are passed. Bu I 
                     have not tested this subroutine. I leave this to
                     Rahul Shetty.

               [--> radmc-3d_v0.20_29.12.09_a.zip]

   +++         I think I now have the movie mode ready. 
               The first tests work nicely!!!

               [--> radmc-3d_v0.20_29.12.09_b.zip]

   +++++       Now I would like to add this aperture mode.
               ---> BUILT, but not yet tested at all!!! It just compiles,
                    and it has the logical structure it should have.


   bug?        During an attempt to make a movie going through a 3-D
               model in spherical coordinates I bumped into a crash
               with the usual stop 1132. No idea why... I am trying
               to figure this out.

               To reproduce this error: 
                  cd examples/run_agn3d_1/
                  idl
                  .r make_movie_journey
               of course after the whole Monte Carlo stuff. At
               image 3 is should crash.

               After a lot of testing I now know that this is the 
               following combination of circumstances:
                - Because I have not introduced the if(.not.crossequator)
                  clause in the checking of the second theta-crossing,
                  and because of a tiny numerical error, the 
                  determinant is not 0, and a solution of the theta-
                  crossing is recomputed that is slightly off. This
                  is a question of cancellation of two large numbers
                  in the computation of the determinant.
                - The ds that is slightly off is not a problem, but 
                  we happen to be also very close to a phi-crossing.
                  So here we have an example of a photon getting 
                  caught in a ribbon. What happens is that instead of
                  the correct icross=6, we keep the wrong icross=3. 
                  
               It might be that this problem can be completely overcome
               if we re-introduce the if(.not.crossequator) clause.
               The only problem I see there is that the self tests
               with the spherical coordinates then no longer pass.
               I would then have to reset these tests. That is not
               a major problem, if we are sure that this is the better
               way. I think we should do this. But I will then move
               to version 0.21 for doing this, and then immediately
               move on to version 0.22. In this way version 0.21 is
               identical to version 0.20, except for the different
               self-test and the clause.

               So for the moment I do not correct this "bug".
               
               [--> radmc-3d_v0.20_29.12.09.zip]


--------------------------------------------------------------------------
                            VERSION 0.21
     THIS IS THE SAME AS 0.20, BUT NOW WITH THE SPHER COORD 'FIX'
--------------------------------------------------------------------------

29.12.09       This is exactly the same as version 0.20, but with
               just this extra clause "if(.not.crossequator)" in
               the amrray_module.f90 to hopefully prevent the
               crash that I discovered above. I expect, however,
               that this means that the self-test for the spherical
               coordinate cases has to be redone.

               I checked: for the run_spher1d_2 the results are
               identical. But for run_spher2d_2 the results are indeed a
               tiny bit different (not more than 0.01 K at max, but
               typically more of the order of 1E-6 K), but I think that this
               is a very good results. I now copied the new
               dust_temperature.dat to the benchmark_models/run_spher2d_2/
               directory. Also the image.out is slightly different (relative
               differences of order 1D-8 at max, but usually lower still).
               Also this file is now copied.

               [--> radmc-3d_v0.21_29.12.09.zip]

30.12.09
 still there   The bug is still there... I realize that I should replace
               the clause if(.not.crossequator) by 

                  if(amrray_finegrid_costsq2(amrray_cell%ixyzf(2), &
                     amrray_cell%level).ne.0.d0) then

               Good point. But still does not solve it. Just the next
               step it crashes again.

               I think that I know what the problem might be: I must
               take care of the cyclic nature of phi. I correct for
               this only if icross==5 or 6. But I must *always* correct
               for this. 

               YESS!! Now it is fixed!!!

               Selftest is still passed, so the change that now fixed
               the problem, and the changed clause both do not change
               the results. But it remains true that the results are
               a slight bit different from the ones of version 0.20,
               so this intermediate version 0.21 is still necessary.

               [--> radmc-3d_v0.21_30.12.09.zip]

--------------------------------------------------------------------------
                            VERSION 0.22
--------------------------------------------------------------------------

30.12.09       I started working on the corner-based stuff:

               amr_module.f90:
        ++     Added routine amr_find_corner_cells() which finds all
               the cells that touch a corner of a cell. Gosh, this was
               quite a piece of programming, because one must take care
               of the possibility of edges and corners of the grid, and
               also that cells that touch the same corner may have
               different sizes, AND that one can have the following
               situation:
 
                 +---+-------+
                 |   |       |
                 +---A       |
                 |   |       |
                 +---+-------+

               where one wants to find the cells touching point A.
               All these situations (including that you can have 
               reduced dimensionality) makes this a tough problem.
               I have programmed it, and it compiles. But I have not
               yet tested it.

    bug        camera_module.f90:
               The projection on a flat screen is not done properly.
               ---> Fixed!

               The movie works brilliantly!

31.12.09       amr_module.f90:
               I am adding some routines for piecewise linear slope
               determination. This is a much easier (and faster) way to
               implement the line doppler subgridding stuff I want to do
               than the above corner-based algorithm.
               ---> It compiles again. 

               OK, I am not sure if I should invest the time right now
               to really make the complex line doppler subgridding
               algorithm, because it might take really quite some
               effort, and I currently do not yet see the urgency.
               This may change depending on what Rahul and Simon
               like to do. But let's wait for that discussion. One
               can always avoid the need of this line doppler subgridding
               if one introduces sufficient microturbulent line
               broadning. 

               But today I did come up with a plan of how to implement it:

               1. The ray enters some cell. We determine the slopes for
                  the velocities vx,vy,vz (in spherical coordinates we
                  still have vx,vy,vz, but the slopes are in directions
                  r,theta,phi).

               2. For the ray interval inside this cell (the ray interval
                  being defined as the part of the ray that lies inside
                  this cell) we split this interval into two equal-length
                  sub-intervals: interval A and interval B. This defines
                  three points along the ray: the starting point S, the
                  middle point M and the end point E:

                    <---cell---->
                    |           |
                    |           |
                    S-----M-----E
                    |  A     B  |
                    |           |

                 We know the Doppler shift at S because that was the end-
                 point of the previous interval. Using the velocity slopes
                 and the velocities at cell center (which is not necessarily
                 the same point as M) we can extrapolate the velocities
                 from cell center to point M. This gives us a second
                 Doppler shift. Finally, using again the slopes we can
                 extrapolate the velocities from point M to point E
                 (or equivalently directly from the cell center to point E).
                 We now have three doppler shifts: D_S, D_M and D_E.

              3. We can now determine if we cross a line in the interval A
                 and the same question for interval B. In each case, if
                 true, we compute the location of the crossing and the
                 width of the crossing. We then insert sub-sub-intervals
                 there and do the integration. This is a tricky part of
                 the algorithm to program...

              4. We can, using the slopes, estimate whether there is a
                 crossing *perpendicular* to the direction of propagation,
                 within the size of the pixel. If yes, and if the width of
                 this crossing is less than the size of the pixel, then 
                 we flag to the calling routine that this pixel has to be
                 refined (we can then of course drop any further integration).
                 This is maybe the trickiest part of the whole algorithm,
                 maybe not so much to program, but to find the correct
                 expressions for the perpendicular gradients...

04.01.10      amrray_module.f90
   bug        Somehow, in 3-D spherical coordinates, when I introduce a 
              layer of refinement, I get STOP 7263. Indeed, in spherical
              coordinates I never tried the AMR yet. So we have now
              clearly stumbled on an AMR problem in spherical coordinates.

              OK, I clearly have not set the variable ilr in the call to
              the amrray_find_subcell() subroutine... That is the cause of
              the error. Now let's find the solution.

              I forgot to set the ilr in the select case(icross) stuff.

              NOTE: For icross==1 I must set ilr=2 and for icross==2 I must
                    set ilr=1. Same for icross==3,4,5,6 (ilr=2,1,2,1).

              ---> Fixed

   bug        readradmc.pro
              Somehow the read_amr_grid() crashes.
              ---> Fixed. I had to specify layer_xi[0:nx,0] = xi instead
                          of layer_xi[*,0] = xi, etc.


 still bug    run_agn3d_1/
              The STOP 1132 bug has appeared again. This time after photon
              number 47351000. Wow, that will be a nice challenge to fix!!
              I put the error messages in the file ERROR_MESSAGE. But the
              run was done on macprokees, so I will have to work on it
              when at the office.

              OK, I see when this problem appears: the photon has managed to
              get extremely close to the z-axis. There the slightest error
              in x,y,z will yield amplified errors in the angle phi. On the
              other hand, the phi-crossings are linear equations, so the
              error should be proportional in x and y. Not sure if I 100%
              understand this.  Ah, another interesting issue is that
              (x*dy-y*dx)/sqrt(x^2+y^2) = 0.008 while dz=~1d-2. This 
              means that the direction is also virtually parallel to 
              the phi-plane. Maybe this combination of circumstances is
              the culprit?

              WHAT ABOUT THIS: I use "small" in the following phi-boundary
              check:

                    if(dum2.lt.-small) then   ! Thereby selecting also only outgoing rays
                       ds_try = dum1 / dum2
                    else
                       ds_try = -1.d0
                    endif

              This indeed introduces a potential mini error which then gets
              caught lateron. What about changing "small" to "tiny" here?
              It is, after all, virtually the only place where I use 
              "small" for actual calculations.

              I will check this idea out on macprokees...

  new bug     In the mean time another long model run with spherical 
              coordinates has crashed at photon number 17034000, with
              STOP 1131. Clearly this error happens due to a tiny
              problem when a ray enters the grid from the inside.
              Indeed it happens at the very inner radial boundary.
              No idea how this could have happened. But again the
              error is extremely tiny. If we would not check for it
              with such an extraordinarily tough condition, we would
              not even notice it. 

05.01.10      I really start to be convinced that my tolerance is simply
              too small. In the end, the algorithm is constructed such 
              that even if we are outside a cell (even if we are WAY
              outside a cell), but are officially still inside a cell,
              the next step will be corrected anyway. So there is no
              real need to be so extremely strict. It was good to find
              out that the algorithm is so stable that such exceptions
              happen very rarely. But now that the math seems to be
              correct, we may be less picky.

   &&&&&&     So from now on I introduce "tol" which I set to 1d-8
              instead of 1d-12. This is now the new tolerance for
              the in-cell checking. 

              I am now testing this on macprokees. 
              ---> Seems to work so far.

   Idea       In the mean time I came up with the following idea:
              In spherical coordinates, with a star in the center,
              it is easy to find out on which parts of the "sky" of
              the star the patches with high spatial resolution are.
              I can launch photon packages preferentially in those
              directions. The idea is to weigh them differently then.
              For instance:
                - All photons that immediately pass the grid (i.e.
                  those that move upward) could be already removed
                  beforehand. You can then focus entirely on those
                  photon packages that enter the grid.
                - A photon package that happens to be launched toward
                  a refinement patch (layer) could be split into 4 in
                  the following way: you simply drop the photon and
                  reroll 4 photon packages, constrained within the
                  cone of the refinement layer as seen from the star.
                  This would then ensure that the photon noise in the
                  patches is equal to the photon noise elsewhere.
                  This, of course, is only easy to do in spherical
                  coordinates and with a stellar point source because 
                  then the geometry of the refinement layers as seen
                  from the star are easy. 
              Not yet implemented...

   BUG!!      There is still a problem with the sed mode. Somehow I 
              don't get a spectrum of the dust anymore... At least 
              for spherical coordinates.

              I understand why: the ray belonging to the single pixel
              goes right through the central hole of the spherical 
              grid. So it does not find a celldxmin. 

              ---> Fixed. I introduce a new variable:
                   camera_spher_cavity_relres=0.05 (default), for which
                   celldxmin = camera_spher_cavity_relres * amr_grid_xi(1,1)
                   if the ray passes inside the cavity.

   ++++       viewimage.pro:
              I added the option /local which allows you to make local 
              observer images. This now works pretty cool!

   BUG??      But I found a strange effect in the model of the fargo
              disk + planet with layers. It looks as if the face-on
              838 micron emission is lower inside the layers. Really
              weird... I should check if I calculated the cellvolume
              correctly for those cells. 
              ---> I think this is merely an effect of the low photon
                   statistics (nphot=1d6) for this test model because on the 
                   desktop macprokees computer (where I use nphot=1d8)
                   this problem does not seem to appear.
                   

              [--> radmc-3d_v0.22_05.01.10.zip]

06.01.10      stars_module.f90:
   +          I added a check that the stars cannot be positioned wrongly
              in case of axial symmetry or spherical symmetry.

   bug        viewimage.pro:
              The zoom-in boxes don't work if you use /pc or /au.
              --> Fixed

   todo       Also I want to build in a distance scale factor in the
              viewimage.pro local observer thing, because it is hard
              to actually move along a line with the current 3-D
              observer position method.
              --> Done

   bug        viewimage.pro/camera_module.f90:
              If you first zoom in, and then switch to local observer,
              then the code crashes with too large angle. This is
              strange because the sizeradian is given...
              *** NOT YET FIXED ***
              But you can avoid this error by always zooming out before
              pressing the 'local' button.

              [--> radmc-3d_v0.22_06.01.10.zip]

08.01.10      
  ++++        Attila Juhasz built a COOOL fully widget-based and very
              intuitive GUI for 2-D disk modeling with RADMC-3D. This is
              good stuff. 

  bug?        One of the advantages of this GUI is that it invites playing
              freely with parameters, and I bumped AGAIN on the out-of-bound
              error, this time very quickly after the beginning. It is
              again STOP 1132. Located in examples/run_ppdisk_gui_crash/.
              Go in there and run radmc3d mctherm and you get an immediate
              crash. 
              (fixed, see below).

09.01.10
  BUG FOUND   This is a serious bug, but strange that it was not found
              way earlier. When pre-computing the sin(theta) and cos(theta)
              over the whole grid, i should go from 1 to nn, not nn+1.
              ---> Fixed, and self-test is passed.
              
              [--> radmc-3d_v0.22_09.01.10.zip]

--------------------------------------------------------------------------
                            VERSION 0.23
--------------------------------------------------------------------------

09.01.10      With this version I would like to introduce the weighted
              energies in the Monte Carlo. The idea is this: if you have
              an object with a star/planet of a certain luminosity, and
              you wish to irradiate it by another far-away (but much more
              luminous!) star, then the photon statistics go bad in two
              ways:

               - By far the most photons are launched from the luminous
                 star, while the planet or low-mass-star emits virtually
                 none. This is bad, because even though the low mass star
                 or the planet is very weak in luminosity, it is so close
                 to its surrounding material (disk or atmosphere) that it
                 is dominant or at least important anyway.

               - By far most of the photons of the luminous far-away star
                 miss the object altogether. So this is a huge huge waste
                 of CPU time (calculating random numbers and checking that
                 it, indeed, misses the object). 

              These two problems can be fixed if we allow for variable
              energy of the photon packages, and for selected directions
              of emission for the stars that are located outside of the
              object of the grid. 

              The idea of the variable energy packages is that:

               - Each star has its own assigned energy. This is stored
                 in star_energy(:). In the normal mode all these energies
                 are the same. In the special "equal nphot mode" each
                 energy is calculated separately. 

               - We may need to in fact do this not only for the stars,
                 but also for all other sources. So each source has its
                 own energy. Of course, if some source is zero anyway, 
                 then even in the "equal nphot mode" it will not count.

               - A question is: should we also do an equal nphot mode
                 in the scattering monte carlo? I mean, this would mean
                 that the virtually zero thermal emission at short
                 wavelengths would still eat up photons? I think the 
                 answer is: yes. It would not cause any harm: it may
                 at most eat up half of the photon packages. I would
                 not, however, do equal nphot for the different dust
                 species. That would make no sense.

10.01.10     montecarlo_module.f90

  bug?       There is a clause   if(mc_cumlum3.gt.0.d0) then...
             to circumvent the costly random number generation. I
             think that this should be if(mc_cumlum4.gt.0.d0)...
             ----> Fixed...

   &&        I removed all the extlum_xsphere stuff, and replaced
             it with grid_contsph_x etc., which is, contrary to the
             original extlum_xsphere, always computed when the grid
             postprocessing is done. This means that we have the
             same sphere defined both for the external luminosity
             and for the improved photon statistics for the externally
             located stars.

   &&        montecarlo_module.f90:
             I replaced mc_scat_energy_limit with mc_scat_energy_rellimit,
             because that can be used also for the improved photon
             statistics stuff.

   ++        I added the weighted photons part of the improved photon 
             statistics plan.

             Still have to include the focused launching of photons from
             externally located stars....

   ++        I now also included the focused launching... I hope I did
             it right... It seems to compile fine.
             And it passes the self-test again.

             [--> radmc-3d_v0.23_10.01.10.zip]

10.01.10     Now I switch on the  mc_weighted_photons=.true. by default!
             There is really no reason NOT to switch it on by default.
             ===> Self test crashed now!!! But only the run_test_scattering_1
                  image test. This is logical, because in that test you have
                  now two sources: thermal emission and stellar emission.
                  Here the new methods obviously produces a different result.
                  So for this test we should switch off the weighted
                  photons for the moment.

             More problematic is that the 2-D planet atmosphere model does
             not really produce the effect I had hoped: that the photon
             statistics is better... So there is still a slight problem 
             here.

   bug       montecarlo_module.f90/montecarlo_rotatevec():
             If l<<1 then still you must put vxyz->vecxyz. 
             ---> Fixed.

11.01.10     amrray_module.f90:
 bug found   In checking for crossings with the stellar spheres, we should
             only check for (ihit.lt.0) ! I think that that is the reason
             why things went wrong. *** CHECK BELOW; IT IS TRUE, BUT SOLUTION
             IS MORE SUBTLE ***

             ---> FIXED, So I changed this now! Major change! Let's now
                  hope that this does not cause other troubles. So I
                  now replaced all instances of (ihit.ne.0) with 
                  (ihit.lt.0). *** NOTE: BELOW THIS IS REVERSED!! ***

             In camera_module.f90: The starting point of the rays must be
             beyond the farthest star.

   +         stars_module.f90
             So I added a variable star_maxexterndist which gives a feel
             for how far we must push the start of the rays in the 
             camera module.

 MAJOR BUG   camera_module.f90:
             In the camera module the stellar spheres are sometimes simply
             skipped by accident. This is because I only include the
             spheres if no other refinement is needed. But that is wrong.
             ---> FIXED. I now introduced the "donerefine" flag now, and
                         hope this is better.

 PROBLEM     OK, the above trick with (ihit.lt.0) is wrong... Darn.

             amrray_module.f90, montecarlo_module.f90:
             NEW TRY: I reinstall the (ihit.ne.0) in amrray_module.f90.
                      But I now install the if(amrray_ispherehit.lt.0) 
                      instead of if(amrray_ispherehit.ne.0) in the
                      montecarlo_module.f90.


   BUG       camera_module.f90:
             In determining the smallest stellar sphere in this pixel,
             you should not just take the last istar1... 
             ---> Fixed. Look for istar1 to find the location of the fix.

   BUG       amrray_module.f90:
             In the Cartesian mode:
             I should always check which of the three(!) ds values is
             the shortest. Right now I accidently skip the exit of the
             sphere if the sphere lies outside the grid. This is a big
             fix.
             ---> Fixed.

   BUG       amrray_module.f90:
             I noticed that if icross.eq.0 the routine will return 
             with arrived=.true. That is wrong. Must be:
                 if(amrray_ispherehit.eq.0) arrived = .true.
             ---> Fixed.

   BUG       amrray_module.f90:
             If a ray does not hit the grid at all, in spherical coordinates,
             then the hit of a sphere is not properly accounted for, because
             the coordinates are not updated. The code goes into an infinite
             loop.
             ---> Fixed. Check for if(amrray_ispherehit.ne.0) then from back
                         to find the location.

             Geez, these spheres are a pain... But now it seems to work...

             ===> OK, now the planetary atmosphere AND the star work. You
                  can have primary and secondary eclipse as well, and you
                  can do transit-spectropscopy models. Also the weighted
                  photons seem to work.

   ++        viewimage.pro: small addition: posang entry again.

             [--> radmc-3d_v0.23_11.01.10.zip]


14.01.10

 BUG         The local observer mode does not work with cartesian coordinates.
             It crashes... STOP 6203.
             *** NOT YET FIXED ***

 bug         The mcmono gives a file with only 0.d0... Sounds not good...
             OK, I understand. That is because with the scattering monte
             carlo subroutine I do everything in terms of the scattering
             optical depth. If that is zero, then you are in trouble...
             It is interesting that I did not get NANs...

 solution:   I put alpha_s(:)  to 1d-99 minimum. Since double
             precisions go to 1d-349 or so this should be still very
             well within the range of doubles. Then the absorption optical
             depth automatically comes out of the scattering optical depth
             even if that is rediculously small...

18.01.10     montecarlo_module.f90/walk_full_path_scat():
 MAJOR BUG   The "ener = energy" statement is too early if the modus of
             mc_weighted_photons is set.
             ---> Fixed

 bug         montecarlo_module.f90/write_meanint_to_file():
             I accidently used freq_nr instead of mc_nrfreq.
             ---> Fixed

*****************************************************************************
18.01.10     montecarlo_module.f90/walk_cells_scat():
 MAJOR BUG!  It seems that there is another bug in the scattering, a pretty
             bad one. When we reach the end of a segment, we have the 
             following formula: dtauscat = taupath-tau. This should be
             dtauscat = dtau... This is a serious bug. I did not discover
             this because I did not yet truly test the scattering mode!
             The bugfix is marked by "MAJOR BUGFIX 18.01.10". It is such
             a serious bug that I need to stop and make a new version!
             ---> FIXED
*****************************************************************************

             But it means that I have to change the scattering test case        
             of the self-test: run_test_scattering_1/. 
             ---> Done (in version_0.23)

             [--> radmc-3d_v0.23_18.01.10.zip]

--------------------------------------------------------------------------
                            VERSION 0.24
--------------------------------------------------------------------------

18.01.10     The self test passed succesfully (with the modified scattering
             model of course). I will make a version backup now, which 
             is in principle identical to radmc-3d_v0.23_18.01.10.zip.

             [--> radmc-3d_v0.24_18.01.10.zip]

    bug      montecarlo_module.f90/write_meanint_to_file():
             A minor bug: I still used the old style of writing cell
             contents to file. This would not work for the layer-style AMR. 
             ---> Fixed. I now implemented the amr_nextcell(index) stuff.

    ++       readradmc.pro:
             Added the possibility to read the mean intensity file by
             a=read_data(/meanint). The data is then in a.jnu.

23.01.10     I checked the differences that Rahul reported between the 
             mctherm results for v0.17 and v0.24. It could be traced back
             to the mc_weighted_photons improvement. 

01.02.10     examples/run_agn_3d_1/:
             I fixed the readopac problem (readopac is now in readradmc.pro)

             I also added the scattering and line transfer tests to the
             examples.

             [--> radmc-3d_v0.24_01.02.10.zip]

01.02.10     Dima Semenov suggests optimization flags "-march=native".
             At 64-bit OS/CPU machine "-m64" would work fine too, 
             in particular, for tasks that want to address more than 
             2Gb of RAM. Thanks Dima! I will keep this in mind for 
             later testing.

12.03.10

  BUG??      In selftest/benchmark_models/run_herbigae_1/ I first computed
             the temperature with "radmc3d mctherm". That went fine. Then
             I did "radmc3d image lambda 1.05 nostar" and the MC model went
             fine, but the code then simply stalled completely. With shark
             I found it is indeed stuck in the find_next_crossing(). No idea
             what is going on. It also got stuck without "nostar". That 
             did not matter.

             The problem does NOT appear if you have "nofluxcons" switched
             on. So it must have to do with extreme refinement...

             I added a message that it does the image rendering now.

             ---> So I should check the refinement. I know that it should
             be a quite strong refinement, but I never thought it was this
             extreme.

 !!!         AHA, I think that this is related to the extreme grid refinement
             I have near the inner edge!!! So I have to make sure that the
             recursive pixeling is done in a cleverer way...


--------------------------------------------------------------------------
                            VERSION 0.25
--------------------------------------------------------------------------

14.03.10     Since it is a while ago that I really made big change to the
             code, and since version 0.24 worked fine, I decided to make
             a new version, and fix the extreme sub-pixeling problem in
             there.

             >>> NOTE added on 15.06.10: Now this is also fixed in 0.24 <<<

             So the idea to fix the extreme sub-pixeling problem is to
             allow only a maximum aspect ratio of a cell to be taken
             into account. That is, if you have a very high refinement
             in R, but not in Theta and Phi (I mean: not AMR-refinement,
             but simply smaller-and-smaller (R_{i+1}-R_i)/R_i), then
             the sub-pixeling will be limited to some fraction of the
             min(dx_theta,dx_phi). 

             In camera_serial_raytrace() I replaced the line

                 celldxmin = min(celldxmin,max(dumr,min(dumt,dump)*dummy))

             with

                 celldxmin = min(celldxmin,max(dumr,min(dumt,dump)* &
                                 max(dummy,camera_min_aspectratio)))

             and introduced camera_min_aspectratio, which limits the 
             extremeness of the sub-pixeling. I make its default value
             0.05. You can change it in the radmc.inp file.

  bug        camera_module.f90/camera_serial_raytrace():
             I found a small bug in the celldxmin calculation when the
             ray goes through the central hole of the spherical coordinates.
             It has to be celldxmin = min(celldxmin,XXXXX). Fixed.

             I did not yet test if the above two fixes work properly...  

23.03.10     I have been pondering about the heaviness of the scattering
             monte carlo runs that are done at each wavelength of a 
             spectrum. If you make a large spectrum, then it could take
             forever. One possible solution could be to have a separate
             nphot_spec which is used for spectra. After all, you integrate
             anyway over the images, so you don't need so many photons.

  +++ &&&    I now implemented this: I added nphot_spec to the mc_params
             structure. I "fool" the spectrum subroutine, because in 
             main.f90, just before calling camera_make_spectrum(), I
             do:

                nphot_scat_original    = rt_mcparams%nphot_scat
                rt_mcparams%nphot_scat = rt_mcparams%nphot_spec

             and then, after the camera_make_spectrum() call, I restore:

                rt_mcparams%nphot_scat = nphot_scat_original

             This was the least invasive method. As a default I take
             for now nphot_spec = 10000, i.e. 10x smaller than the
             nphot_scat default. Note that you can also modify this
             value in radmc.inp as well as on the command line.

  --         Also removed some misinformation from the banner when there
             is nothing to do.

             [---> radmc-3d_v0.25_24.03.10.zip]

24.03.10     For backward compatibility with RADMC-3D I would like to 
             implement the circular images.

                  ************ IN PROGRESS ************

30.03.10     idl/natconst.pro:
   BUG       There was still an old version of natconst.pro in the idl
             directory. That did not yet contain more accurate values
             of "c" and other constants.

             ---> FIXED
             
13.05.10     
  +++++      Added diffusion_module.f90, which is going to be the RADMC-3D
             version of the diffusion algorithm in RADMC. 

                  ************ IN PROGRESS ************

             These modules will for the moment (until they are finished)
             not be linked in.

14.05.10     camera_module.f90:
     &       If inclstars is set on the command line, but no stars are
             available, the camera will no longer stop, but just give 
             a warning.

14.05.10     montecarlo_module.f90:
    ++       Passively building in the skipping of ultra-optically-thick
             cells as possible sources of photons for the scattering
             monte carlo. For the moment it is still all commented-out.
             All additions are marked with !----TO-ADD----.
             Apart from a good algorithm to find the typical cell size
             for spherical coordinates, I think I now built it in. It
             now simply ignores very optically thick cells (where the
             ABSORPTION optical depth is larger than mc_scat_src_maxtau,
             which has to be user-specified). But in the ignored cells
             it put the scattering source term to the local Planck 
             radiation estimate, so that in case you move inside the
             cell with local observer, you still see the scattering
             source term. BUT SO FAR THIS IS ONLY PASSIVELY IMPLEMENTED!!

  bugfix     Also fixed a small bug: 
               mc_cumulthermemis(:) = mc_cumulthermemis(:) / ( mc_thermemistot + 1d-90 )
             i.e. added + 1d-90 to the denominator.

15.05.10     montecarlo_module.f90:
  done       Done implementing (passively!) the skipping stuff. See above.
             But it is not yet uncommented. See !----TO-ADD---- tags.

15.05.10     amr_module.f90:
             I had a new look at the corner-based algorithm that I 
             programmed on 30.12.09. I worry that there is a bug in the
             code. Coming back to the following situation:

                 +---+-------+
                 | 1 |       |
                 +---A   2   |
                 | C |       |
                 +---+-------+

             where C is the starting cell, and A is the corner of interest,
             you must make sure that you use the *smallest* cell of C's
             neighbors to find the cell opposite to C (which is in fact
             the same big cell 2). I now check for the smallest *level*,
             which is in fact the biggest cell...

             Question: if you use the smallest cell, are we sure that 
             we then are fine? Could the cell 1 also be as big as cell 2?
             Answer: I don't think so, because of the hierarchic structure.
             So we are safe if we choose the smallest cell.

  bugfixes   OK, so I fixed these bugs, plus a few small others. I hope
             that the routine is now OK. 

   ++++      Next we must make a list of gridpoints. Let us do this 
             using a large array with vertexindex as the pointer. 
             We also make an array for the leafs, telling which 
             corner points we have. We then must make a subroutine
             that adds a point, checks if it already exists, and
             relinks all the references. Still much work to do.

             Geez, this is also not easy...

             OK, I now finally think I got it. At least, I now have
             the entire vertex grid set up, with all links. So each
             vertex has 8 links to cells, and each cell has 8 links
             to corner vertices. While setting the whole thing up, 
             I also do self-consistency checks. 

             --> It seems to compile. But I have not tested it yet,
             since it is late at night. 

             BUT STILL TO DO: The re-do of everything with precisely
             the right number of corner cells. THIS IS NOT YET DONE.

16.05.10     I realize that there is still a bug in the above routines.
             The mere fact that a cell touches a vertex does not mean
             that the vertex is that cell's corner.

     &&      OK, I now added the flags for which cell has "this"
             vertex as its corner. To save memory we do this in 
             bit-form. But since fortran-90 does not yet have IBIT()
             intrinsic (this is fortran-95, but I prefer to stick to
             fortran-90 for the moment), I will have to come up with
             a clever way to manipulate bits myself.


17.05.10     montecarlo_module.f90 and ioput_module.f90:
             I must make sure that the unformatted I/O always uses 
             kind=8 integers.
             ---> DONE

18.05.10     amr_module.f90
   !!!!      I seem to have the vertex grid working!! But it is not yet
             used by RADMC-3D.

19.05.10     dust_module.f90, main.f90
   &&&       I want to build in the option 'noscat' and 'inclscat' on the
             command line. Therefore I had to replace scattering_mode by
             scattering_mode_def, and copy the latter to the former at
             each cycle of modeling.
             
19.05.10     camera_module.f90:
             I now start building in the use of the corner-based grid 
             by the camera module.

24.05.10     camera_module.f90:

  &&&&&&&    IMPORTANT: In the camera_serial_raytrace() subroutine I 
                        now replaced the entire stuff that fills the
                        src and alp arrays with a call to a new 
                        subroutine camera_get_src_alp(). This may 
                        perhaps make the raytracing a bit slower?
                        I may want to check this. The reason why I
                        did this is to make one single point in the
                        code where these things are computed, and use
                        this camera_get_src_alp() also at other locations,
                        for instance the place where we compute the 
                        vertex-based src and alp. 

             camera_module.f90:
   ++        I finished the camera_compute_snualphanu_at_vertices(inu)
             subroutine.

24.05.10     amrray_module.f90:
             I make icross a global variable inside the amrray module.
             It now is called amrray_icross.
             I also install it in the amrray_find_next_location_cart().

   ++        camera_module.f90:
             I finished camera_find_srcalp_interpol(x,y,z,snu,anu).

             NOTE: For lines, in particular in 2-D axial symmetry, 
                   this is not yet sufficient.

             It compiles.

             [--> backup_24.05.10.zip]

             Some more bugfixes. 

             Testing on run_simple_1_layers/
             It seems to work! Even with grid refinement!!! Wow!

             But strangely I tend to get somewhat higher intensities out
             compared to the firstorder integration...

             OK, this seems to only take place in the optically thick
             limit. This is therefore an effect of the interpolation.
             The question is now: which one is the correct one?
             Also, I now interpolated alpha and source, not alpha and
             jnu (as I did in RAYTRACE).

             For now let us stick to this version and back it up.

             [--> radmc-3d_v0.25_24.05.10.zip]

25.05.10     camera_module.f90:
  +          I built in the other way of interpolating the sources: you
             can now choose to interpolate the emissivity j_nu instead
             of the source function s_nu with camera_interpol_jnu=.true..
             This can be set in radmc.inp.

             Result: The two different interpolation styles yield very 
             similar results, only a slight difference for the optically
             thick case where the difference between first order and 
             second order is enormous.

             Note: In the model run_simple_1, where at 10 micron the 
             differences between first and second order are pretty
             considerable (30% or so), the differences at 100 micron
             are minimal. This is to be expected, but important to just
             check.

             [--> radmc-3d_v0.25_25.05.10.zip]

             Since we have already got quite far with everything, and
             even though we are not yet finished with many implementations,
             I think it is time to close this version. 

             NOTE: I HAVE NOT DONE SELF-TESTS FOR SOME TIME. I should 
             do this now on the desktop computer. 

    ++       One more thing that I want to add is a button in viewimage.pro
             for second order integration. DONE.

   ????      STRANGE: I now find differences between linear and second order 
             also for 838 micron, where the object should be optically thin.

   bug       With viewimage.pro if I do second order integration and also press
             tau, then the code crashes with an array boundary overflow
             at line 1533 of camera_module.f90.
             Hmm. Strange. I now set the intensity(inu) to intensity(1) for
             the tau integration. Not elegant...

             It seems that I need to do more testing.

28.05.10     camera_module.f90:
  bugfix     I fixed the bug with the tau integration. Now that works
             also for second order integration. But somehow the results
             are not 100% the same. Strangely enough the results of
             the intensity ARE the same, for lambda=1000 micron. This is
             really strange...

   +++       userdef_module.f90:
             Now, as a standard, if a command-line option is not recognized,
             RADMC-3D will stop with a complaint. This has to be done in the
             userdef_commandline() routine, because this routine is called
             if other (standard) command-line options are not recognized.

 BUG FIXED!  I found out what is going on with the second order integration:
             I did not switch off the integration when outside a cell. This
             meant that at the start and finish(?) the vacuum still had one
             of the two values alpnu_prev, alpnu_curr non-zero. That 
             produced spurious additional flux. 

             Indeed: now it works fine!!

   NOTE:     At 10 microns there is still a bit of difference in the images,
             but not in the tau anymore. I think that this is now really
             related to the better integration for second order integration
             when it comes to optically thick-thin transitions with coarse
             grids.

 Still Bug!  The images at incl=60, phi=30, if you zoom in, produce a strange
             "interference pattern". No idea why that is. I have to check
             this out...

 BUG FIXED!  OK, another bug found: The "ilr" variable in the amrray_module.f90
             was meant for the next cell, and this is exactly the opposite
             of what I meant. Now I set the amrray_icross correctly in the
             camera_find_srcalp_interpol(x,y,z,snu,anu) routine. And indeed,
             now the images look really smooth!!! 

 small bug   amrray_module.f90:
             When the next cell is smaller, then we must make icross<0. 

             OK, this is brilliant! The images, also at high tau, look now
             really smooth and nice, much better than with the first order
             integration. This is a worthy finishing point of version 0.25!

             [--> radmc-3d_v0.25_29.05.10.zip]

---------------- AFTER END OF VERSION --------------

02.06.10     stars_module.f90
  bugfix     In the stars_module you should not use igrid_coord, because
             that may not yet be set by the time the read_stars() is called.
             Now using amr_coordsystem instead.

02.06.10     stars_module.f90
  bugfix 2   If we have spherical coordinates, and we place a star inside
             the grid, then the amr_findcell() is called with x,y,z, but
             for spherical coordinates r,theta,phi should have been used.
             This is now fixed. We also do some checks: if equatorial mirroring
             then the stars must be on the z=0 plane. If not, they must NOT
             be on the z=0 plane. Also they must not be on exactly y=0, unless
             at (0,0,z). Also done.

   !!!!!     montecarlo_module.f90
             I enforce now that if mirror symmetry is used, all photons from
             stars point upward initially! 
             I also replace (if mirror symmetry) the z->abs(z) with a 
             check that z=0.
             NOTE: These things are done at TWO locations, one for the 
             bjorkmanwood and one for the scattering MC.

             [--> radmc-3d_v0.25_02.06.10.zip]

03.06.10     amr_module.f90
             I notice that for cyclic boundary conditions the vertex grid
             is still not yet 100% correct. We must treat these boundaries
             specially. But this appears only to be the case for the 
             self-tests in the amr_module.f90. Done.

             --> It works now also for the protoplanetary disk model.
  bug            BUT: at the inner rim of the disk there is a dark 
                      ring, I guess two theta-cells wide. I must still
                      figure this out...

  bug        I also notice that there is (also in the rim) still a sawtooth
             profile; weak but clear. I think that this is related to the
             above problem. Something with the linear interpolation is still
             not good.

 BUG FIXED   amr_module.f90:
             The bugs mentioned above were because of the fact that I have
             the z-dimension (=phi) switched off. The amr_find_corner_cells()
             routine mistakenly nullified some cell pointers in that case.
             This does not happen in 3-D.

             ----> Now also the run_herbigae_1 model (ported from RADMC)
                   works fine with second order integration! Very nice! 
                   The difference with first order integration are, however,
                   in this case not so large. But you can see it when you
                   zoom in to the very inner wall.

             [--> radmc-3d_v0.25_03.06.10.zip]

03.06.10     In spherical coordinates, with the fine grid near the inner
             edge of the disk in the RADMC-ported disk models, the sub-
             pixeling takes a large amount of time, in spite of the limit
             to the sub-pixeling set by camera_min_aspectratio. But it does
             give, after some time, a nice image. I now want to count the
             number of sub-pixels done.

             camera_module.f90:
  +++        I now added this diagnostics. Two new variables in the 
             camera_module.f90: camera_subpixeling_npixtot and
             camera_subpixeling_npixfine.

04.06.10     camera_module.f90:
  ~~~~       I am not satisfied with the way that I compute the celldxmin
             in spherical coordinates. This must be done better.

15.06.10     camera_module.f90:
             I added an option to let the rectangular imager dump a list
             of (sub-)pixel positions to a file. This is useful for
             debugging and figuring out why some image ray-tracing may
             take so much time: where does RADMC-3D spend it's time 
             ray-tracing? 

             The flag is camera_diagnostics_subpix, whic his of course
             by default .false.. You can switch it on with the command-line
             option 'diag_subpix'. 

  -->        With this diagnostics I found that the subpixeling is in 
             principle OK, but it appears to be much to fine. Somehow
             the criterion for subpixeling is too tight... I have to
             look into this.

             [--> radmc-3d_v0.25_15.06.10.zip]

16.06.10     Again returning to the subpixeling issue in spherical
             coordinates. I need to limit the aspect ratio also in
             theta direction...

        &    OK, I added a new parameter camera_min_drr, which limits
             the total refinement ratio dr/r. That helps a lot! But I
             am still not really satisfied. It gets really complex! And
             it is not self-consistent. 

             In principle I should calculate three vectors: s_r, s_theta
             and s_phi, which give the thickness of the cell in r, theta
             and phi direction multiplied by the respective unit vectors.

20.06.10     (At Haneda airport, Tokyo)
             I finally got the stuff w.r.t. the celldxmin and subpixeling
             in spherical coordinates reasonably OK. It is now about 10x
             faster than before.

             [--> radmc-3d_v0.25_20.06.10.zip]

01.07.10     main.f90
   &&        From now on, if a radmc3d.inp is found, it will read that,
             instead of radmc.inp

   TODO      Also change this in the manual
   TODO      Also change this in the examples

  bugje      dust_module.f90
                if((ispec.lt.1).or.(ispec.eq.dust_nr_species)) then
             must be
                if((ispec.lt.1).or.(ispec.gt.dust_nr_species)) then
             fixed.

   ++++      idl/
             Added radmc2radmc3d.pro 
             This is a subroutine can converts the input files of RADMC
             to the input files of RADMC-3D directly. 

             [--> radmc-3d_v0.25_01.07.10.zip]

02.07.10     viewimage.pro
  bugfix     Problem with frequency.inp fixed

             rtglobal_module.f90
  bugfix     Light speed made more accurate.

  bugfix     montecarlo_module.f90: montecarlo_compute_freqdep_luminosities()
             Fixed problem when frequency is very close to the boundaries of
             the frequency domain.

             [--> radmc-3d_v0.25_02.07.10.zip --> radmc-3d_v0.25_02.07.10_old.zip]

   ++        stars_module.f90
             Added a check that if the stellar radius is not small 
             compared to the inner radius of the spherical coordinate
             grid, it will give a warning.

   bugfix    montecarlo_module.f90:
             While I allowed for finite-size star in spherical coordinates
             in the thermal monte carlo, I still had the old cartesian
             cell-finding stuff in the scattering monte carlo. So for 
             spherical coordinates and finite-size stars the program stopped.
             That is now fixed.

   bugfix    radmc2radmc3d.pro:
             I now added automatically the line istar_sphere = 1 to the
             radmc3d.inp file.

             [--> radmc-3d_v0.25_02.07.10.zip]

*************************
 TODO: Test if indeed the photons that hit a stellar surface will be 
       removed!
*************************

03.07.10     lines_module.f90
  BUGFIX     Bug found by Rainer Rolffs: 

               dummy = nrdens / ( pfunc * lines_level_gdeg(ilevsubset(1),ispec) )

             must be

               dummy = nrdens / pfunc

             of course... Stupid mistake. It did not show up as long as
             lines_level_gdeg(ilevsubset(1),ispec)=1, which was the case
             in most models. But in some models it may not be 1, in which
             case it completely produced a wrong answer. 
             ---> FIXED.

             [--> radmc-3d_v0.25_03.07.10.zip]

30.07.10     main.f90
  &&         I now changed radmc.out to radmc3d.out. 

02.08.10     Problem with selftest:
  selftest   The selftest could not be passed, because in the 
             rtglobal_module.f90 I improved the value of the light
             speed to the more accurate one. This then meant that the
             values of the self-test were slightly different, which
             caused the selftest to crash. This means that there is
             no problem with the code. But it means that, once the
             self-test with the old values of c has passed, we must
             make the new version of the benchmark results, this time
             with the new values.

   !!!       ---> Self test of version 0.25 with old value of the
                  light speed in rtglobal_module.f90 has passed!
                  (I skipped the userdef things, though). So I am
                  confident that the code is still fine!

             rtglobal_module.f90:
      &&&    I replace 2.99792458d14 with 1d4*cc . This is much more 
             organized.

  selftest   I now remade the selftest benchmark runs, with the new
             (better) version of rtglobal_module.f90: With more
             accurate value of c. Also I replaced radmc.inp with
             radmc3d.inp everywhere consistently.

             ---> The new selftest is now passed by the correct 
                  version 0.25 (with better c). This is obvious
                  because I used this version to remake the 
                  selftest, but it is nevertheless good to know
                  that it seems all self-consistent again.

             [--> radmc-3d_v0.25_02.08.10.zip]


02.09.10     
  mini-bug   main.f90:
                 elseif(buffer(1:12).eq.'subbox_theta') then
                 elseif(buffer(1:11).eq.'subbox_nxyz') then
             instead of 1:11 resp. 1:12. Fixed. Thanks, Attila!

 LARGE BUG!  camera_module.f90:
             The velocity field in spherical coordinates must be
             v_r, v_theta and v_phi. 
             ---> Fixed, I THINK! Not yet tested...

             ---> Attila Juhasz tested it and it seems to work.

03.09.10 and
07.09.10     lines_module.f90
  problem    In reading the leiden database, Rainer Rolffs found that it
             is not always guaranteed that the energy levels are given 
             at the accuracy needed to compute the frequency nu_0 of the
             line centers.

  &&&&       I now change this: From now on we take the actual frequencies
             listed in the line list instead of computing them from the
             level energies. At the same time we will do a consistency
             check.

  NOTE!      In the self-check run for molecular lines there may now be
             a slight difference due to the non-exact same nu0...

16.09.10     
   BUGFIX    lines_module.f90
             I forgot that the frequency in the Leiden files is in GHz.
             That is now fixed, by multiplying by 1d9. 

             [--> radmc-3d_v0.25_16.09.10.zip]

17.09.10
   BUGFIX    idl/readradmc.pro
             The light speed was not at high enough precision. That caused
             small line shifts... Fixed.

             [--> radmc-3d_v0.25_17.09.10.zip]

24.09.10     idl/readradmc.pro
   BUGFIX    If /basic is given as keyword, then the read_amr_grid() should
             not read the entire AMR grid... Fixed!

   +++       idl/readradmc.pro
             At all printf statements to the biway pipe I now added the
             flush statement. 

--------------------------------------------------------------------------
                            VERSION 0.26

I ALREADY MADE A VERSION 0.26 BEFORE, BUT THAT BECAME A SPAGHETTI CODE...
I SIDETRACKED THAT AND START ANEW.

The sidetracked version is 0.26_spaghetti

26.09.10
--------------------------------------------------------------------------

26.09.10     In the previous attempt for 0.26 I implemented:
              - Doppler catching of the lines
              - Stokes components of the radiative transfer and dust
              - Modified Random Walk
              - Axisymmetry and spherical symmetry for scattering
              - Skiptau option
              - Spectra with circular images
             But the implementation really stranded in too much complexity.
             I now go back to version 0.25 and re-build the above things
             in one small step at a time, covering multiple versions...

             First the doppler catching is important. Right now the 3-D
             cartesian coordinates are most used among the RADMC-3D users,
             so I will focus on improving that mode first. 

   ++++      camera_module.f90
             I am now re-implementing the doppler catching stuff, and
             some small improvements such as a proper average position
             xav,yav,zav for line-related stuff. You can find most of
             the added stuff by searching for camera_catch_doppler_line
             and for xav. I also changed the local prev_x,prev_y,prev_z
             into ray_prev_x,ray_prev_y,ray_prev_z.

   +         rtglobal_module.f90
             Added ray_prev_x,ray_prev_y,ray_prev_z.

   ++++      lines_module.f90
             Added lines_source_alpbase() and lines_anujnu_from_base()
             subroutines meant for use with the doppler catching method.

   +         main.f90
             Added switch for doppler catching: command line option 'doppcatch'

             ----> It compiles fine!

             I went through the doppler catching code fragments, and so far 
             it seems fine.

27.09.10     idl/readradmc.pro
   bugfix    Forgot to close the file if /basic was set. Fixed.
   bugfix    ispec --> imolspec. Fixed.


27.09.10     lines_module.f90:
  BUG!       Somehow the automatic determination of which lines are 
             active and which are not does not work! All lines appear
             to be always active. That is wrong. No wonder that the code
             for line transfer is so slow...

             Yes, this was because I did not divide lines_maxturbc by cc...
  fixed      ---> Fixed. 

   &&        I increased lines_widthmargin from 3.d0 to 12.d0. 

  NOTE:      PLEASE CHECK THAT WITH THIS FIX THE LINES ARE STILL DONE OK!

  bugfix     While precalculating the src and alpbase on the vertices I
             forgot to set the direction vector properly. Fixed.

  bugfix     In the doppler catch stuff: Count nr of active lines, not nr
             of subset lines. Fixed.

  bug?       camera_module.f90:
             I think that when using the second order integration, I do not
             treat the first point along the ray properly. It seems that
             I simply set the sources there to zero. This may turn out to
             be OK if you start outside of the domain, because then the first
             point along the ray indeed has zero source. But we may want to
             check this. Also, for the doppler catching method this goes
             wrong, because it would mean dividing by a zero line width...

  bug        camera_module.f90:
             I forgot to also interpolate the line stuff. Is now done...
             ---> OK, now it works better.

   !!!       ===> Wow, now the line doppler catching seems to work! That
                  is pretty good! Already the non-catching was better 
                  than the normal second order mode, because the line
                  profile is calculated at the cell interfaces instead
                  of at the cell centers. But with the catching it is
                  even better.

             BUT: The line image in run_test_lines_4/ at vkms=90 has still
             a few fringes. And there is still a weird thing happening
             at the corners of the grid. But I think that for a first
             case it works pretty well! At least the fluxes are relatively
             smoothly varying with vkms, in contrast to the case with
             linear integration.

             [--> radmc-3d_v0.26_27.09.10.zip]


28.09.10     I don't know what these strange fringes mean. One way to find
             out is to store the entire velocity field at the vertices.
             This should not matter, but we'll see.

    BUG?     The problem seems to also appear already with the dust 
             continuum! It is therefore a problem with the second order
             integration, not particularly with the line transfer or
             the doppler catching! 

             I find the problem ONLY if we put the densities in the boundary
             cells to (nearly) zero... You get fringes on the edges of the
             domain... 

    &&       I removed camera_cell_turb() and camera_cell_temp(), because
             that is double storage (we already have these values in the
             lines_microturb() and gastemp() arrays).

    test     I want to test if the second order algorithm uses the correct
             cell surfaces...
             ----> This was OK.

 Was no bug  The "BUG" above was no bug. The fringes on the edges of the
             domain if you remove the density of the outer cells is to be
             expected! It is a logical consequence of the second order
             interpolation scheme, and are exaggerated due to the logarithmic
             plotting. So: False alarm!

22.10.10     
23.10.10     lines_module.f90:       <<FIXED ALSO IN V0.25>>
   +++       Make distinction between .uinp (double precision) and .usinp
             (single precision).
  BUGFIXES   Also fix bugs that made the reading of gas_velocity.uinp
             and microturbulence.uinp go wrong.

03.11.10     camera_module.f90, lines_module.f90, userdef_module.f90:
  ++++       Added new line mode of Thomas Peters!


30.12.10     I went again a bit through the camera_module.f90, comparing
             it with version 0.25, just to check if nothing weird was
             changed or so. Seems fine. 

02.01.11     Over het probleem met de line transfer met kleine lijnbreedte:
             ik denk dat ik weer wat het probleem is. Ik heb een solid-body
             rotation, zodat er op elke line-of-sight altijd precies 1 
             geprojecteerde snelheid is. Echter, de interpolatie is altijd
             lineair. En ik heb een belachelijk kleine line width. Dat 
             betekent dat de kleine afwijkingen van perfect 1 velocity
             per line of sight door de lineare interpolatie een groot 
             effect kan hebben. Dus ik denk dat de methode gewoon werkt
             zoals het moet, maar dat de test case gewoon te extreem
             is. In andere gevallen zal het waarschijnlijk makkelijker
             gaan.

02.01.11     I now check out the comments by Rainer Rolffs made on 10.12.2010.
             
             - Double precision for the gas velocity
             - If the microturbulence and/or the gas temperature are 
               determined in the userdef module, then the lines_maxturbc and/or
               the gastmax are not calculated. Now, whenever the 
               read_microturbulence() is called or the read_gas_temperature()
               the lines_maxturbc and/or gastmax are calculated always, even
               if the data is already in memory.
             - I have now done the same for the gas velocity and the quantity
               lines_maxveloc derived from it. Same issue.
             - I included (but commented out) a line
                 ! write(stdo,*)  '   In image: including Molecule', ispec, '  Transition',iline
               in the subroutine lines_find_active_lines_levels. It might be
               useful sometimes to switch it on by umcommented it. You can 
               then see which lines are included in the image. 

             All done now.

03.01.11     
 bugfix      camera_module.f90:camera_make_circ_image(): I forgot to
             also put the clause (.not.camera_secondorder) for the
             Multi-wavelength Method 1. Is now done.

 Still bug   The doppler catching mode bug is still there. 
             Strange... I now redid the line model run_test_lines_4 at 
             lower resolution, so that I can check what the problem is
             with the doppler catching algorithm: run_test_lines_3_lowres/.
             I now have a 8x8x8 model. Also I put to zero (=1d-99) *two*
             rows at the edges of the domain instead of just one. I want
             to be absolutely sure that the problem is not with the 
             boundaries. What I find, especially with

                 radmc3d image npix 100 lambda 2.60075760000000E+03 
                    posang 0.00000 incl 90.0000 phi 30.0000 pointau 
                    0.00000 0.00000 0.00000 zoomau -150.06684 150.06684 
                    -150.06684 150.06684 nofluxcons nostar secondorder 
                    inclline doppcatch

             that there is a huge line flux at some cells, also in the
             cell row that is zeroed (the one just next to the non-zeroed
             part). But only at the bottom, not at the top. Strange strange.
             This is clearly a bug!

             Let's see: I tried to check the interpolations of the doppler
             shift on the vertices. That appears to be alright. 

             Now let's make a 1x1 pixel image at the position of the 
             renegade line. Now I can trace the camera_serial_raytrace()
             step by step. 

03.01.11     Question: Am I sure that in second order integration the bit
             of ray before entering the grid is not accidently included?

             Note: For the simple test of a rigidly rotating sphere there
             should not be any reason for the doppler catching algorithm
             to switch on...

             In fact, it is strange that even in the first order integration
             method you see anything... Hmmm... 

04.01.11     Continuing bug hunting. I now have it cornered in the solid
             body rotation example, where I see the following:

               - The Doppler shifts at the vertices at the edges of the
                 domain are of course deviant from the perfect solid 
                 body rotation because they have been averaged over only
                 half of the adjacent cells. We would have to do extra-
                 polation to get this right, but that is not worth it. 

               - In principle all vertices involved in the last crossing
                 with a cell wall (before the ray escapes toward the 
                 observer) should, in the test case I set up, have zero
                 (=1d-83) alpha. However, I see that ONE of the four
                 vertices has instead 1E-13... Interestingly, if I do
                 the same image at another y, this does not happen.
                 So this is clearly a bug! I think it might be that the
                 assignment of vertices has gone wrong somehow.

   +         amr_module.f90:
             I added the subroutine amr_check_vertex(vidx) to enable
             a simple consistency check of a vertex: Is this vertex
             indeed the correct corner to all the cells it claims to
             be a corner of? It checks the positions of the corner
             as given by all cells connected to this corner. I used
             the subroutine during debugging and so far the corner
             cells all seem fine.

1 "bug" found: Damn... I found out that the problem lies, at least
             partly, due to an error in the setup of the line test
             model: 

               openw,1,'numberdens_co.inp'
               printf,1,1                      ; Format number
               printf,1,nx*ny*nz               ; Nr of cells
               printf,1,1                      ; Nr of species
               for iz=0,nz-1 do begin .................

             should be

               openw,1,'numberdens_co.inp'
               printf,1,1                      ; Format number
               printf,1,nx*ny*nz               ; Nr of cells
               for iz=0,nz-1 do begin .................

             This created a 1 in the number density of the first 
             cell... OK, that is now clarified.

             It fixes the strange feature at the bottom of the
             8x8x8 test case. But it still does not solve (not
             surprisingly) the strange fringes in the 16x16x16
             model. Funny is that in the 8x8x8 model the entire
             line is gone... 

10.01.11     [--> radmc-3d_v0.26_10.01.11.zip]

11.01.11     lines_module.f90
  &&&        I improved the summing of the thermal and microturbulent 
             local line width. Original:

                a     = lines_ray_turb(1) + sqrt(2*kk*lines_ray_temp(1)/lines_umass(ispec))

             new:

                a     = sqrt(lines_ray_turb(1)**2 + 2*kk*lines_ray_temp(1)/lines_umass(ispec))

             The difference is minimal, but it is more correct.

             NOTE: This will likely make the self-test of lines fail.
             I will have to redo that self test.

11.01.11     camera_module.f90

 BUG FOUND!  Finally I have the bug in the doppler catching algorithm: The
             integration step size ray_ds must also be divided by nsteps!

   !!!!      YES! This now fixes the problems! Now the test problem
             run_test_lines_5, which is a linear y-gradient of v_y,
             works perfectly! Also the flux remains very stable when
             the velocity channel is varied! Finally the doppler catching
             works!!

11.01.11     [--> radmc-3d_v0.26_11.01.11.zip]

14.01.11     It seems that simply putting the velocities at the corner cells
             at the edges of the domain to the average of the 4 (instead of
             8) neighboring cells creates a little problem. If the density
             at the edge is high enough for line to be optically thick, then
             the sudden zero velocity gradient in the edge cell creates a
             weird effect. Of course, it means that the model setup is not
             very good, because the edges should never matter.  For now I
             will note this in the manual, but I will not try to fix this.

   !!!!      A much more serious and fundamental issue (not a bug!)  is how
             to treat shocks. A shock is, physically, an almost infinitely
             thin transition of velocities, densities and temperatures. In a
             numerical hydrodynamic simulation, however, such a shock is
             always smeared out over a few cells. This is artificial. But
             these artificially smeared cells may create line emission that
             is unphysical! This is a very fundamental problem, and I would
             not know how to easily deal with this.

             Intensive testing by Rahul Shetty revealed that for his 3-D MHD
             boxes this problem in fact plays a big role.

             But to illustrate the effect we designed a simple 1-D shock
             model test: run_test_shock_1/. This test is a classical shock
             model, with a maximum density ratio of (gamma+1)/(gamma-1). For
             gamma=7/5 this means a maximum density ratio of 6. This is
             still rather modest. And indeed the effect of smearing out the
             shock is not so much, but it is detectable! 

16.01.11     Improved the manual a bit more. Added a figure about the
             first- and second-order integration.

             Self test passed, except (expectedly) the line transfer test,
             because that one has changed since the last version (see 
             above, at 11.01.11).

             [--> radmc-3d_v0.26_16.01.11.zip]

17.01.11     Fixed small problem with the examples/run_test_lines_5/ 
             model. Now I increased the velocity gradient, so that 
             the difference between the use of doppler catching and
             the normal integration becomes totally obvious.

             [--> radmc-3d_v0.26_17.01.11.zip]

23.02.11     Small mini changes.
             Plus: I change lines_mode=10 to lines_mode=-10, because 
             all negative lines_mode values mean on-the-fly calculation
             of level populations and all positive ones mean: global 
             storage of level populations.

     &&      Fixed problem in the manual: Old ways to switch lines_mode
             are now fixed to new way.

     ++      Added a warning that if dust scattering AND lines are used,
             the code can become slow.

 STILL BUG   Somehow the doppler catching algorithm still produces
             strange results. In the run_test_shock_2/ test model,
             if I switch on second order integration, but not doppler
             catching, I also get an overestimation of the thin line
             (the emission before the shock). However, if I put 
             camera_interpol_jnu = 1 in the radmc3d.inp file, then
             the problem appears to be solved. This is strange, 
             because camera_interpol_jnu = 1 means that instead of
             alpha_nu and S_nu, we interpolate alpha_nu and j_nu.
             I always thought that it would be more accurate to
             interpolate the source function S_nu than the emissivity
             j_nu (note: formally one has j_nu = alpha_nu * S_nu). 

27.02.11     
 FOUND       I found out where the problem lies. It is very subtle,
             and is not a bug, but a problem with the algorithm. 
             In tests/run_test_shock_2_idl/ I programmed a 1-D line
             transfer code in IDL to model the shock test. There I 
             could explore exactly what happens when interpolations
             are done in particular ways. 

             Result: If the source function S_nu is interpolated,
             then things go badly wrong in the shock test case!!
             It is essential to interpolate j_nu and alpha_nu, but
             NOT the source function. I must say that I do not 
             understand very much why this is the case. I have always
             thought that it is more "physical" to interpolate the 
             source function, because that is directly related to
             the temperature. But the IDL program shows clearly that
             this is not the case. And the IDL program reproduced
             exactly the same problem as RADMC-3D had if S_nu is
             interpolated.

             Consequence: We must make the j_nu interpolation as
             the standard interpolation for second order integration.   
             And we must interpolate j_nu also in the doppler catching
             method, meaning that we have to also introduce a jnubase.

------------------------------------------------------------------
27.02.11     SUBSTANTIAL CHANGE: INTERPOLATE JNU INSTEAD OF SOURCE
------------------------------------------------------------------

             First we backup the current source directory:

               src/  --->  src_before_jnu_fix/

             Now I am now going to fix this problem. It requires a change in
             the algorithm: Instead of source and alpbase in the
             lines_source_alpbase() we will do jbase and alpbase in the
             lines_jnu_anu_base() subroutine.

  BIG FIX    lines_module.f90, camera_module.f90:
             Now I make the big fix of the problem. This involves
             also the renaming of variables and subroutines.

  bugfix     At the same time I also fix another occurrance of 
             the a=a_turb+sqrt(2kt/mu) error, which should be
             a=sqrt(a_turb^2+2kt/mu).

             ---> Now the shock test seems to work! No major
                  problems anymore!

             [--> radmc-3d_v0.26_27.02.11.zip]

  
--------------------------------------------------------------------------
                            VERSION 0.27

Also here I already made a version 0.27 before, but I redo this now,
starting from radmc-3d_v0.26_27.02.11.zip

--------------------------------------------------------------------------

28.02.11     lines_module.f90, camera_module.f90, userdef_module.f90, main.f90

   &         In lines_serial_addto_jnu_alpnu() I now move the a = ...
             line (calculating the line width) out of the 
             do ilinesub=1,active_nrlines(ispec) loop.

   +++       Now I re-implement Thomas Peters's Voigt profile stuff. But
             instead of Thomas's pre-calculated line profile, I modified
             the Humlicek Voigt profile subroutine to a single-valued
             function. Now it does not require precalculation anymore.
             But the Lorentz delta factor still requires the userdef
             call. This is also now implemented.

             Now we are back to where we were with the previous v0.27
             attempt.

             [--> radmc-3d_v0.27_28.02.11.zip]

28.02.11     lines_module.f90, camera_module.f90
 ++++++      Adding the LVG stuff of Rahul Shetty, but making some
             major changes to his modules to ensure compatability
             with the overall development philosophy of RADMC-3D.

             I extract the statistical equilibrium calculation and
             put it into a separate subroutine. This allows us to
             later use the same subroutine for e.g. escape probability
             or full non-LTE line transfer. Keeps things nicely 
             modular.

             I also made a separate subroutine for the finding of
             the velocity gradient. Note: For now this does not
             allow AMR refinement yet. Will be added in the near
             future.

             NOTE: It is still not clear how to assign collision
             partners to molecules. Example: we have two molecules,
             one with pH2 and oH2 as partners and one with pH2
             and He as partners. We don't want to have to duplicate
             the pH2 number density file. But how to assign this?
             One idea is to have in the lines.inp file these
             assignments. The other idea is to have always the same
             collision partners for all molecules - but this is
             restrictive. I like the first idea better, but it is
             cumbersome, both for the user and for the programmer...

             --> Still in progress...

01.03.11     Progressing with this. It is quite a lot of work, 
             because I want to implement it 100% flexibly. So the
             molecules can each have arbitrary number of collision
             partners, each with any number of temperature 
             sampling points. This is all quite a bit of data
             management. 

             --> Still in progress...
             
02.03.11     OK, I now implemented the fully flexible collision
             partner data stuff. Now, in the lines.inp, you can
             (if the iformat is .ge.2) specify for each molecule
             which molecular names are associated with each
             of the molecular collision partners. In principle
             it would have been nice if this could be done
             directly from the molecular data files, but the 
             Leiden database format does not have a unique
             naming convention for hte names of the collisional
             partners. So we have to do it in the lines.inp.
             
             --> Still in progress...
             
   +++       I added a warning in main.f90 when the sub-pixeling
             is excessively large. It also gives a tip to the 
             user how to diagnose the subpixeling.


12.03.11     lines_module.f90/read_partition_function(action)
  BUG!!!     The partition function is calculated correctly
             only as long as the statistical weight of the 
             ground state is 1. This is clearly an error in 
             the code!

  FIXED      I now fixed this error.


18.03.11     camera_module.f90:camera_get_src_alp()
   BUGFIX    Thomas Peters pointed me to the little bug that if we do not
             include any dust, then the camera_get_src_alp() routine is
             still trying to calculate the dust emission. This gives 
             troubles. Added an if(rt_incl_dust) statement to fix this.

             Note: To include this if(rt_incl_dust) statement, I had
             to also change the order of if()-statement and do-loop for
             the frequency. I think that this is not problematic. Just 
             keep it in mind in case strange things happen.

20.03.11     Finally I managed to compile the code again with the new 
             LVG mode included. Wow, that was a lot of work. Not so much
             the technical stuff, but to make it fully compatible with
             the other modes, and fully flexible.

             I now also build in what I had already separately built in
             into the v0.26b branch:

> 18.03.11     So let us build in the user defined opacity and emissivity
>              routine:
> 
>              userdef_module.f90:
>              Added userdef_srcalp()
> 
>              camera_module.f90/camera_get_src_alp():
>              Added:
>                if(rt_incl_userdef_srcalp) then
>                   call userdef_srcalp(ray_index,camera_nrfreq,inu0,inu1,     &
>                                       camera_frequencies(:),src(:),alp(:))
>                endif
> 
>              main.f90/read_radmcinp_file():
>              Added the possibility to set the flag incl_userdef_srcalp=1.

20.03.11     OK, it compiled again.

             [--> radmc-3d_v0.27_20.03.11.zip]

23.03.11     
   ++        Added AMR capability to LVG.

   ++++      Added optically thin non-LTE level populations mode. 

             [--> radmc-3d_v0.27_23.03.11.zip]
             
24.03.11     I think it is time to include also the modes that determine the
             level populations beforehand and store them...  I now also
             remember the original reason to use subsets of levels: Use the
             full set of levels to do the non-LTE population calculation,
             but then only store a subset of them to prevent too much memory
             usage. I think that over the course of time I forgot this
             original goal and misinterpreted my own intentions ;-).

       bug   I also found that the collision partner number densities were
             not read for lines_mode.eq.-4... Now fixed.

    bug      I removed the check that for non-LTE transfer no subset can
             be specified. This perhaps applies to full (non-local) non-LTE
             transfer. But we can check for that later.

  BIG WORK   I now worked a large part of the day on implementing the 
             positive lines_mode modes, i.e. where the level populations
             (for at least a subset of the levels) are stored in a global
             array: for each cell. This is a memory-intensive method, but
             it can be for many purposes much faster than the on-the-fly
             methods. It is quite a bit of work, mainly, as usual, data
             management. 

             But now it is also possible to write the populations to file.

             Unfortunately, now that the code has become so extensive and
             versatile, the data management is the part that costs the most
             programming by far. Quite boring stuff, but important.

  CHANGE     In lines_compute_ltepop_subset(), formally lines_compute_ltepop()
             I used the ilevsubsetidx array to address the levelpop() array.
             Now, however, I decided to only use the subset index for the
             big level population array (the one storing this for each cell)
             to save memory, but not for a local level population array.

             This means that I also change this in the addressing of the
             lines_ray_levpop() array, i.e. in lines_serial_addto_jnu_alpnu()
             subroutine.

             I therefore completely eliminate the arrays:
               lines_levelup_subsetindex(:,:)
               lines_leveldown_subsetindex(:,:)
             because we do not need them anymore. 

             Note: The subroutine lines_compute_and_store_local_populations()
             must be located in the camera_module, because it calls a 
             subroutine of the userdef_module, which cannot be accessed from
             the lines_module.f90.

    done     Now this seems to be done, and it compiles again.

             [--> radmc-3d_v0.27_24.03.11.zip]

24.03.11     Now that I'm at it, I'll also implement the line list mode. 
             Wow, that was also quite a bit of work to attach all the wires.
             But now it seems to be implemented.
             And it compiles.

             None of this is tested yet, though. This is to be done in the
             next few days.

             [--> radmc-3d_v0.27_24.03.11b.zip]

24.03.11     I also check again what happens if no stars are specified. I
             heard from several people already that the code stops/crashes
             under that condition.

   bugfix    montecarlo_module.f90:
                star_fraclum(:) = 1.d0
             must be moved to within the do istar=1,nstars loop and replaced
             with
                star_fraclum(istar) = 1.d0
             This will avoid using an array that has not been allocated yet.

             [--> radmc-3d_v0.27_24.03.11c.zip]

             I now also updated the manual to include explanation about
             all these new options.

   ++++      I also added the opac/ directory, which gives a set of 
             subroutines to produce dust or line input files from 
             data from standard databases of the WWW.

             [--> radmc-3d_v0.27_24.03.11d.zip]

25.03.11     montecarlo_module.f90
  bugfix     Small additional bugfix related to the nstars==0 issue:
             if(.not.allocated(mc_energy_stars).and.(nstars.gt.0)) stop 9211
             (added the nstars.gt.0 clause).

  ++ &&      Added some more luxury stuff, fixed a couple of bugs, 
             added writepop and calcpop options, updated the manual.

             First non-LTE tests work.

             [--> radmc-3d_v0.27_25.03.11.zip]

26.03.11     lines_module.f90
  bugfix     Fixed a bug with the level subset selection (subset_mode==1).

             Revamped the section on subset selection in the manual.

             Done a simple 1-zone test for [OIII] 5007 Ang line. 

             [--> radmc-3d_v0.27_26.03.11.zip]

28.03.11     camera_module.f90
             Fixed a few tiny bugs, not important (just how things are
             displayed on the stdo).

             Now testing the LVG mode. This seems to go wrong. No
             convergence due to an Infinity.

 BUG FIXED   There was a bug in lines_compute_velgradient(): I accidently
             used ray_index instead of index. That is why the velocity
             gradients became so strange. 

             [--> radmc-3d_v0.27_28.03.11.zip]

04.04.11     montecarlo_module.f90:
 bugfix      If there is no thermal emission, then the normalization of
             the thermal emission can go wrong. This is a bug found by
             Attila Juhasz. It is now fixed by adding the line

                mc_cumulthermemis(nrcells+1) = 1.d0

             at the end of the montecarlo_compute_freqdep_luminosities()
             subroutine. 

             A similar thing I now fixed in the subroutine for total lum:
             montecarlo_compute_total_luminosities(). I added the line

                mc_cumulthermemis(nrcells+1) = 1.d0

             and also changed the line above that to:

                mc_cumulthermemis(:) = mc_cumulthermemis(:) / ( mc_thermemistot + 1d-90 )

             just in case someone makes a more without thermal 
             emission, although that should never be the case (unless 
             perhaps for strange test cases).

    &        Tiny change in the warnings for absense of collision
             partners.

    bf       Tiny bugfix: I accidently made it impossible to do
             radmc3d image iline 1 vkms 10
             because it then complained that widthkms is not set.
             Of course that is not necessary if a single image is made.
 
05.04.11     amr_module.f90:
    bf       If spherical coordinates are used, but in phi-direction you
             have only 1 cell, then the phi-direction must be switched off,
             or else the code gets stuck... I now added an error stop.

28.04.11     amr_module.f90:
             I am hunting for the bug in the corner vertex algorithm,
             discovered by Thomas Peters, which (only) takes place when 
             you have the following arrangement of AMR cells:

               +---+---+-------+
               |   |   |       |
               +---+---+       |
               |   | A |       |
               +---+---O---+---+
               |       |   |   |
               |       +---+---+
               |       |   |   |
               +-------+---+---+

             I think that it must have something to do with the
             identification of all the cells touching the central vertex in
             this plot (vertex marked with "O").

  bug found  YES: I got it! It is indeed the "O" vertex, but the one that is
             halfway up the big cells. If you start with cell A and identify
             all the x, y and z neighbors, then the x-y, x-z, y-z neighbors,
             and finally the x-y-z neighbor, then you will have the big
             branch in the bottom right as a neighbor. This branch has
             children. The branch itself does not have "O" as a corner ("O"
             is halfway one of its ribbons). But it DOES have children. When
             we now reduce this big branch, we are not allowed to assume
             that this branch has "O" as its corner. But the algorithm so
             far DOES assume this. We clearly must implement an piece of
             code that deals with this type of (rare) events.

             Not easy to do.

Bug fixed(?) amr_module.f90:
             Wow, I worked most of the day on this. But I now hope that I
             fixed the problem. It compiles. 

             First test: It does not crash anymore. 

             But: It also did not crash anymore when I only swapped the
             checking of corner and the reduction part. Strange. I think
             that this is because in the original version, with the 
             swapped code fragments the cell that causes a problem would
             simply be flagged as amr_loc_corner(ix,iy,iz)=.false.. It
             would then be the wrong cell, but it would not be checked,
             so no crash occurs. It would still be wrong, however.

             Now with the "real" fix, it also does not crash. Hopefully
             it is, however, a "real fix".

             [--> radmc-3d_v0.27_28.04.11.zip]

06.05.11     Bug report from Paul Clark. Apparently when trying to read
             the level populations from a file, it goes wrong. Somehow
             the level populations are in fact NOT read. They found that
             it seems to happen in the following line of lines_module.f90:

              if(action.eq.0) then
                 return
              elseif(action.eq.1) then
                 if(allocated(lines_nrlevels)) return
              endif

             I think that indeed this is an error. Because lines_nrlevels
             are already set by the molecular data file. What it should
             be instead, I think, is:

                 if(allocated(lines_levelpop)) return

             Let us see if this fixes the problem.

07.07.11     Bugfixes by Thomas Peters:

             In main.f90, replace the line
                  elseif(buffer(1:6).eq.'zoomradian') then
             with
                  elseif(buffer(1:10).eq.'zoomradian') then

             In readradmc.pro, replace all occurences of the line
                  if n_elements(options) then begin
             with
                  if (n_elements(options) gt 0)  then begin

14.07.11     userdef_module.f90:userdef_srcalp()
  warning:   I should make it clearer in the description of this subroutine
             that the user MUST test if index.gt.0, otherwise you get
             garbage...
             I will do this by adding some commented-out example stuff.

16.07.11     main.f90: 
    bug      The 'myaction' check had buffer(1:6), must be buffer(1:8)

17.07.11     
  ++++++     viewimage.pro and example 
             I added now an example model to the examples/ directory in which
             we have a purely user-defined transfer function. I also added
             corresponding features to viewimage.pro: keyword /usertrans.
             A new input file is added: transfer.inp, with (for viewimage.pro)
             the default file transfer.inp.default . 

             This allows you to use RADMC-3D as a fancy volume rendering tool,
             in which you vary the transfer function on-the-fly.

18.07.11     
    &&&&     viewimage.pro and readradmc.pro
             Upon request of Thomas Peters, I made it now possible to also
             set the upper intensity for each of the three RGB colors 
             directly (i.e. which intensity is assigned to color=255). 
             This can be now done with the "absolute scale" button when
             you have /color activated.


10.08.11     userdef_module.f90:
             Added a warning:
              WARNING: In this subroutine you are not allowed to use
                       write(stdo,*), because the stdo is not yet
                       set. Reason: The defaults are set before the
                       command-line options are interpreted (so that the
                       defaults can be overwritten by command-line options),
                       but the stdo depends on whether the user calls
                       RADMC-3D as a child or not, which is given by the
                       command-line options.

11.08.11     Added Benoit's ramses2radmc.pro subroutine in the idl/ directory.

11.08.11     I've got some reports of a bug that if you do not include
             microturbulence, the code may crash. I *think* it is because
             of the second order integration, where in the subroutine
             camera_compute_snualphanu_at_vertices(inu) there is a line:

                    trb = trb + lines_microturb(ray_index)

             without checking if the array exists. 
             --> Fixed.

14.09.11     
BUG REPORT   Thomas Peters finds a bug in the line module that is related
             to the new indexing of the level populations. Not yet fixed.

15.09.11     Bug hunting...

             OK, let's see: On 24.03.11 I made the changes that cause the
             current problem. There I wrote that I completely eliminated
             the arrays lines_levelup_subsetindex(:,:) and 
             lines_leveldown_subsetindex(:,:). The idea was that the 
             subset selection is only meant to (a) save computing time
             and (b) save memory for the BIG arrays. For the SMALL arrays
             we could still use the original indexing for the levels,
             i.e. the indexing from the original molecule_***.inp files.
             That does not mean that more computation is done, but just
             that we store level populations in the SMALL arrays still
             using the original indices, NOT the index for the subset of
             levels. 

             I have done a grep on lines_levelup_subsetindex in version
             0.26 of the code, to see where it was used. It was only 
             used in the lines_module.f90, and only for the array
             lines_ray_levpop(). But the ilevsubsetidx array in the
             lines_compute_ltepop() subroutine is linked to the 
             active_levels_subsetindex array upon the calling of that
             subroutine. So I must find out where that is set and where
             it is used. I also must find out where the lines_ray_levpop
             array is used. 

             In the lines_module.f90 the active_levels_subsetindex array is
             only defined and filled with the correct values. Only in the
             camera_module.f90 in the call to lines_compute_ltepop() is
             this array in fact used. In the new version this is no longer
             used (which is correct; i.e. the way it should be).

             It seems that the only inconsistency I can find is that the
             lines_compute_ltepop_subset() has levelpop array as an 
             argument which, now, has length lines_nrlevels(ispec), not
             active_nrlevels(ispec).

   &&&&&     camera_module.f90 and lines_module.f90:
             So we add an extra argument to lines_compute_ltepop_subset()
             which is the real length of the levelpop array. I can't 
             imagine that this would fix the bug, but it is definitely
             something that should be fixed anyway.

             [--> radmc-3d_v0.27_15.09.11.zip]
             
06.10.2011   Rainer Rolffs came a few days ago with an interesting problem:
             how to convert RADMC-3D output to another code with non-
             regular gridding. The idea I put forward is simple: a 
             subroutine amr_sample_3d() that basically samples values
             at a given list of points. So I added this:

     +++     amr_module.f90/amr_sample_3d()
     +++     ioput_module.f90/do_sample_extract_and_write()
             
             (temporarily stopping at this point)

09.10.2011   Finished the sampling stuff. 
             Also added a section about this in the manual.

             [--> radmc-3d_v0.27_09.10.11.zip]

01.11.2011   Attila Juhasz has gone carefully through the new linelist
  BUGS!!     mode of the lines_module.f90. He found many bugs:
              - read_linelist(): The variable "species" was not set
                to lines_speciesname(ispec)
              - read_linelist(): The file must be opened
              - read_linelist(): Extra read(1,*) header necessary before
                the do iline=1,lines_nrlines(ispec)
              - read_parfunc_from_linelist(): The variable "species" was 
                not set to lines_speciesname(ispec)
              - read_parfunc_from_linelist(): The file must be opened
              - read_partition_function(): if(.not.allocated(lines_level....))
                was too strict. since it is not allocated in linelist mode
              - Attila created a separate routine called
                lines_find_active_lines_linelist()
              - The lines_linelist_gup, lines_linelist_gdown, 
                lines_linelist_eup and lines_linelist_edown must be
                all doubles, not integers.
             He also found a small problem with the normal line mode:
              - write_levelpop(): Must take care of numbers smaller than 1d-99.

    &&&      lines_module.f90/write_levelpop():
             In writing the level populations to file I first copy them to
             an array dummy(:), which is an allocatable array. I then 
             check if some of these numbers are smaller than 1d-98, and
             set those to 0.d0. Then they are written to file.

    &&&      He also implemented his lines_find_active_lines_linelist()
             into the camera_module.f90

 ALL FIXED   I now implemented all his bugfix suggestions. 

             [--> radmc-3d_v0.27_01.11.11.zip]

04.11.2011   Together with Mario Flock working on visualization of Mario's
             3-D MHD disk simulations, using the user-defined srcalp function
             from the userdef_module.f90. It works great! You can get
             beautiful images!

  bugs       But the test also revealed some bugs:
               - When you have only a pie of the disk, then somehow the
                 phi-boundary is ignored, and sometimes the code simply
                 crashes.
               - For 3-D spherical coordinates, the second order integration
                 mixes up the phi = 2pi and 0 values somehow. Code crashes.

    fix      amrray_module.f90:
             One small bug (but presumably not the cause of the above error)
             is that I do not set ds_p1 and ds_p2 to -1d99 in case dum2.eq.0.d0.
             ---> fixed. 

  BUG        amrray_module.f90:

                   amrray_sinp1 = sin(amr_grid_xi(1,3))
                   amrray_sinp2 = sin(pi-amr_grid_xi(1,3)) 
                   amrray_cosp1 = cos(amr_grid_xi(amr_grid_nz+1,3))
                   amrray_cosp2 = cos(pi-amr_grid_xi(amr_grid_nz+1,3)) 

             must be:

                   amrray_sinp1 = sin(amr_grid_xi(1,3))
                   amrray_sinp2 = sin(amr_grid_xi(amr_grid_nz+1,3)) 
                   amrray_cosp1 = cos(amr_grid_xi(1,3))
                   amrray_cosp2 = cos(amr_grid_xi(amr_grid_nz+1,3)) 

  BUG        amrray_module.f90:

                   phi_p2   = amr_grid_xi(1,3)

             must be

                   phi_p2   = amr_grid_xi(amr_grid_nz+1,3)

  BUG        amrray_module.f90:

                   dum1 = x00*amrray_sinp1 - y00*amrray_cosp1

             must be

                   dum1 = ray_cart_x*amrray_sinp1 - ray_cart_y*amrray_cosp1

             (same for p2). 


06.11.2011

  BUG        amrray_module.f90:
             Must check if ds_p1 (or ds_p2) is >0.d0, otherwise the ray will
             hang...

08.11.2011   amrray_module.f90:

  BUG        I now understand what goes wrong with the non-cyclic phi grid:
             If you find the crossing with the plane representing the edge
             of the pie-piece, then it could be that you actually hit the
             surface on the opposite side of the center, i.e. phi +pi or
             -pi. We have to check for this.

             ---> OK now it works better. I still get some strange effects
                  of little black dots for camera angle at phi=130 for 
                  the pie test of Mario... Strange... But it looks already
                  much better.

  BUG        I think I know what the problem is: the confusion between phi=0
             and 2*pi. 
             ---> YES, that is now also fixed! Now the image of the pie looks
                  great! 

             [--> radmc-3d_v0.27_08.11.11.zip]

23.11.2011   ioput_module.f90/compute_dust_mass()
  bug        If amrray_mirror_equator is set then the compute_dust_mass()
             subroutine must include a factor 2. 

25.11.2011   The fish-eye projection for the Planetarium Dome seems to work!
             The only thing which irritates is that the viewer does not
             want to always look straight up. So we must include a way
             to have the pointing direction shifted with respect to the
             center of the circular projection. This is essentially already
             possible with the camera_zoomcenter_x and camera_zoomcenter_y
             variables. For the movie they are set from the cameras_zmc_x
             and cameras_zmc_y arrays. For individual images they can be
             set with the zoom-in options on the command line.     

     ++      I am now adding the possibility to shift the center of the
             image away from the center of pointing. I added the following
             variables:

               camera_localobs_zenith

             I then added the rotation of the camera in the fisheye (dome)
             projection. 

26.11.2011   Daniel Harsono had troubles with the spectrum creation with
             the aperture. I think that I found the bug:

    BUG      camera_module.f90/camera_make_spectrum()

               do inu=1,camera_nrfreq

             must be replaced by 

               do inu=1,backup_nrfreq

             because the camera_nrfreq is now 1. Fixed!

27.11.2011   Still a bug...

    BUG      When making the spectrum frequency-by-frequency (which must be done
             when aperture is used), I reduce the camera_nrfreq, but that is 
             apparently dangerous. I need to fix this... 

             OK, the idea is that we "fool" the camera module to think that we
             have only 1 frequency. We thus backup the frequency array, but I
             forgot to also make a separate array for the spectrum (because that
             will also be "fooled" into a 1-element array). 

             Fixed.

             [---> radmc-3d_v0.27_27.11.11.zip]

05.12.2011   
  BUG!       lines_module.f90/lines_amr_recursive_velo()

             Anika Schmiedeke found a bug in the lines_amr_recursive_velo()
             routine. It used the leaf index to index the cell, but since
             a branch cell is not necessarily a leaf, it might have leafindex
             0, in which case the routine does not find the branch. So the
             fix is to use the pointer to the child itself, not the index.
  Fixed!     This is now fixed and it solves the problem.



06.12.2011   I added some formulas in the chapter on line transfer to make
             the definitions more clear. 

             [---> radmc-3d_v0.27_06.12.11.zip]

13.12.2011   Some users report that the code is very slow if you use 
             doppler catching and calculate the LVG populations on-the-fly.
             The reason for this is that doppler catching requires second
             order integration, which requires the camera module to 
             compute the image for each frequency separately (it cannot
             trace all frequencies simultaneously, because it would require
             too much memory space to store all source functions for all
             frequencies at the cell corners). 

             It therefore seems that LVG and doppler catching AND on-the-fly
             populations is a not so happy combination. 

             The solution is to store the populations (positive lines_mode).
             But for very big models and large level diagrams this can be
             memory-intensive. 

             The solution to THIS is then to make a selection of the levels
             for which you want RADMC-3D to store the populations. This
             can be done in the lines.inp

    +        I added a warning and a few tips in the code, if this very slow
             method is used.

             [---> radmc-3d_v0.27_13.12.11.zip]

13.12.2011   
   bugfix    idl/radmc3dfits.pro
             Stella Offner found that the "filename" variable is not
             used in the writefitsimage() subroutine. This is now fixed.

             [---> radmc-3d_v0.27_13.12.11.zip] (overwrite)

14.12.2011   Some thoughts on improving the data-management for second order 
             integration of line emission/absorption. The main reason why
             the on-the-fly LVG + doppler catching is so slow is because
             I extrapolate the src(inu) and alp(inu) to the corners. If we
             want to make a spectrum of, say, 1000 frequencies, and if we
             want to trace all frequencies simultaneously for each ray, 
             we would need to store 2000 values at each grid cell corner
             point. For large models this is too memory consuming. 

             So: why do I extrapolate the src(inu) and alp(inu) to the
             corners? Why not just extrapolate gasdens and gastemp to the
             corners and compute the level populations at the corners 
             (instead of at the cell centers)? This means we have to store
             only gasdens and gastemp at the corners (more precisely: the
             molecular number density). And we can then do the on-the-fly
             LVG for all frequencies simultaneously for each ray. Also the
             velocity gradient is now computed along the ribbons! That is
             much more mathematically robust on AMR grids. 

             OK, we then also have to store the three velocity components.
             But that should not be a major problem. 

             So if we want to do this: What about the dust? The dust 
             scattering requires a one-frequency-at-a-time approach anyway.
             So if we have dust scattering, we cannot do the all-frequencies
             simultaneous approach. But that is not a problem, because in
             this case it is not a slowing-down factor. If we do not include
             scattering, then we can anyway do first order integration and
             we do not have the problem either. Only for second order 
             integration of dust continuum we switch back to one-frequency-
             at-a-time approach. But also here it is not too much a slowdown.

             So we could keep everything as it is for the dust, and for the
             lines we could try to include the above idea. 

             I think, however, that this requires us to go to version 0.28.

             Another thought is the parallelization with OpenMP. Christoph
             Federrath has been working on implementing this. Still some
             problems to fix, but it seems promising. Also this requires
             to go to version 0.28.

29.12.2011   Thomas Peters mentioned that the integration of the opacity
             (to obtain total optical depths) only works for inu=1. This
             is unnecessary and confusing.

                       if(camera_tracemode.eq.-2) then
                          !
                          ! Integration of the optacity to obtain the optical depth
                          ! (useful for debugging etc)
                          !
                          intensity(1) = intensity(1) + 0.5d0 * ( ap + ac ) * ray_ds

              must become

                       if(camera_tracemode.eq.-2) then
                          !
                          ! Integration of the optacity to obtain the optical depth
                          ! (useful for debugging etc)
                          !
                          intensity(inu) = intensity(inu) + 0.5d0 * ( ap + ac ) * ray_ds

              at various places. Search for "camera_tracemode.eq.-2" to find
              these places.

   Fixed      This has been fixed.

              Note: there where we have "elseif(camera_tracemode.eq.-1) then"
              we in fact integrate the density alone. There we do NOT need
              to replace (1) with (inu).

             [---> radmc-3d_v0.27_29.12.11.zip] 


==============================================================================
                           VERSION 0.28
==============================================================================

29.12.11     A number of people complained that even without AMR the code
             requires a huge amount of memory. That is because even if no
             AMR is used, the cells are connected via the AMR tree. Since
             the AMR cells contain information about which are the
             neighboring cells, and each cell has 6 neighbors, and 
             slots for 8 child-cells (which are unused in case of a regular
             grid) this wastes a lot of memory space. 

             I will now try to implement the possibility that neighbors are
             found directly (without the AMR-tree) if the grid is regular.

             For security, I make copies of the original files, so that I
             can always do a diff to see what I changed:

                cp amr_module.f90 amr_module.f90_ORIG
                cp amrray_module.f90 amrray_module.f90_ORIG
                cp montecarlo_module.f90 montecarlo_module.f90_ORIG
                cp camera_module.f90 camera_module.f90_ORIG
                cp lines_module.f90 lines_module.f90_ORIG
                cp ioput_module.f90 ioput_module.f90_ORIG

             I now introduce a new flag: 

                amr_tree_present

             In the amr_module.f90 I now make it a default that if there is
             no refinement planned (levelmax.eq.0) then the AMR tree is not
             allocated at all.

             In amrray_module.f90 I search for all occasions of the names
             amrray_cell and amrray_nextcell. At all these locations I
             make if(amr_tree_present) statements. Instead of the
             amrray_cell I then have ix_curr, iy_curr and iz_curr. 
             In the amr_module.f90 I add a subroutine 

                amr_regular_get_ixyz(index,ix,iy,iz)

             which can translate from the cell index to ix,iy,iz. The
             reverse (going from ix,iy,iz to index) is simple:

                index = ix+(iy-1)*amr_grid_nx+(iz-1)*amr_grid_nx*amr_grid_ny

             or even more compact:

                index = ix+((iy-1)+(iz-1)*amr_grid_ny)*amr_grid_nx

             so for that there is no separate subroutine necessary.

    Note:    Apart from implementing the regular grid option, I also
             had to make the following minor changes to the AMR part:

              - amrray_find_next_location_cart() as well as
                amrray_find_next_location_spher():
                  if(.not.associated(amrray_cell)) then  ------>
                  if(ray_indexcurr.le.0) then 
                This should be no problem, because amrray_cell
                can never be a branch-that-is-not-a-leaf. So if
                it is present, it IS a cell, and thus has a >0
                ray_indexcurr.

    NOTE:    For future implementation of unstructured grids:
             By systematically separating out the AMR-tree stuff from the
             regular grid stuff everywhere in the code, it will also become
             easier at some later point to implement the unstructured
             gridding, because one then only needs to add an extra
             elseif(tetrad_web_present) or so.

    NOTE:    In cartesian coordinates no cyclic boundary conditions
             are permitted in the amrray_module.f90. Perhaps at some
             later point it might be useful to allow cyclic boundaries,
             at least for e.g. scattering calculations. But for the
             normal mctherm it makes no sense, since no photon
             would be able to escape. 

   BUG       camera_module.f90
             I think (!) that I notice that in putting the source
             functions onto the vertices I do not take care of the
             mirror symmetry option in the midplane. This is not
             very problematic, but it might make the sources a
 not-fixed   bit underestimated at the midplane.

30.12.2011
   BUG!??    lines_module.f90/lines_compute_velgradient(index,velgradient)
             It appears as if this subroutine accidently uses index
             instead of icell for the amr_theleafs() array. If you
             want to go from index to cell you must use the
             amr_index_to_leaf(:) array. This bug will (I think) only
             have consequences if you use LVG on an AMR grid (i.e.
             with refinements) because only then the index and icell
             integers will no longer be the same. 

             I marked the spot with !!! BUG (30.12.2011)
  FIXED      And I fixed it by replacing

               cell  => amr_theleafs(index)%link

             with 

               cell  => amr_index_to_leaf(index)%link

             which should be the correct one.

             I also fixed this in the version_0.27.

             Status so far:
             
             The code still compiles, and if I switch amr_tree_present
             on at all times (also for regular grid) then also the 
             self-test is passed.

             But there is still work to do tomorrow:

               - Check all cellindex() and cellvolume()
               - Check all nextcell() calls
               - Check all uses of index_to_leaf()
               - Check all uses of amr_theleaf....

             For today, however, I stop. 

31.12.2011   I think that I will keep the cellindex() and cellvolume() arrays
             also for the regular grid case. They of course also take up
             memory, but by far not as much as the AMR tree. But it occurs
             so often that I would have to include MANY if-statements into
             the code, which I prefer not to do at this moment. If, later,
             it turns out that it would be useful to eliminate them, then
             this should be very easy to do: just a search for these arrays
             with grep. It might, in fact, be useful, because looking something
             up in an array is also time-consuming. So the loss of time by the
             if-statement might be well compensated by the gain of time by
             not having to look things up. But we can test this at some 
             point later. For now I will not touch cellindex() and cellvolume().

             Now working further on the implementation of an AMR-tree-free
             mode. Now working on the ioput_module.f90 + the stars_module.f90.

             Now all the above points have been checked. And the code still
             compiles. It also passes the self-test, albeit still with the
             AMR tree active. 

             [---> radmc-3d_v0.28_31.12.11_tmp.zip] 

             I now made it possible to force the use of the AMR tree also for
             regular grids using the command line keyword "usetree", e.g.:

                radmc3d mctherm usetree

             This is useful for testing...

             Note: I added "use amr_module" to main.f90

             The testing of the code without the AMR grid still shows up
             bugs... 

             [---> bk4.zip]

  It works!  After some more minor bugfixing, I ran the selftest. The new
             version of RADMC-3D passed all the tests!!

             So it appears, tenatively, that the removal of the AMR tree
             for regular grids is a success!!!!

             [---> radmc-3d_v0.28_31.12.11.zip] 

01.01.2012   Peter Schilke asked me last month whether it would be possible
             to make an "image" that in fact locates the distance to the
             tau=1 surface at every wavelength. That would indeed be useful.
             Strictly speaking one would have to ray-trace in reverse, i.e.
             starting from the observer and tracing back into the object.
             But that would require major changes to the raytrace routine.
             My philosophy is, however, to implement things with as little
             as possible modifications. 

             So here's the strategy: We do TWO images. First we make an
             "image" of the optical depth. Then we make this image again,
             but now we know the point where tau_end-tau(s)=1, and we mark
             the spot. This is then all done in the 

                 camera_tracemode=-3

             mode. I therefore replace all (camera_tracemode.eq.-2) in
             the camera_module.f90 with (camera_tracemode.le.-2).

             Working on it. But in the mean time:

  bug?       camera_set_ray_stars_pntsrc()
             Are the rotations of the dir and position correctly done?
             I see two places where I am not sure. And since Mario Flock
             indeed found this "strange pointsource that moved around
             unpredictably" in his local observer movies, this might 
             be the origin?

  nope       ---> No, not a bug. I checked the signs of the sines and
                  cosines, and they seem to be fine.

             Ok, working further on the tau=1 surface stuff... 

             OK, done. And it compiles again. And it passes the selftest
             again. 

             The command to activate this is, for example:

               radmc3d tausurf 1 lambda 10
             
             And it seems to work! I get indeed the location of the tau=1
             surface, as projected onto the sky of the observer. Also the
             3-D data in the tausurface_3d.out file produce reasonable 
             values. 

             I added the subroutine read_tausurf_3d() to the readradmc.pro

             I added a section in the manual about this new possibility.
             And I added the item to the last section.

             [---> radmc-3d_v0.28_01.01.12.zip] 
             

==============================================================================
                           VERSION 0.29

TODO: 
  - Overcoming the memory-and/or-cpu-cycle-costly LVG mode [Done]
  - Implementing MRW method
  - OpenMP parallelization

==============================================================================

02.01.2012   I now plan to do some more big changes to the code, so it is
             prudent to start a new version, so that version 0.28 (which
             appears to work fine) remains safe.

 !! TODO:    I realize that I need to implement a "maximum column depth"
             parameter for each molecular species, to prevent the LVG 
             method from producing unrealistically high optical depths
             in regions with low velocity gradient.

             So ONE plan for the improved LVG mode is to add an option to
             interpolate not the src and alp to the grid vertices (= cell
             corners), but to interpolate all physical variables to those
             vertices (rhogas, tgas, the number densities of the molecules,
             etc etc). This is more memory consuming, but it would allow to
             calculate the populations at the vertices. The advantage is
             then that one does no longer have to do the second order
             integration one frequency image after the other (and
             recomputing the LVG levels again for each frequency, which is a
             waste of time).  ** THIS IDEA IS DROPPED **

             BUT: I think that I have a better plan. Perhaps I can build in
             that RADMC-3D automatically finds out which levels to store for
             the requested wavelength range. I already do this in the
             levels_active method. Now this only needs to be extended to
             allocate the big population array to store these (and only
             these) levels for the to-be-rendered multi-frequency image.
             In a way it would make the "subset" of levels automatically
             for us, rather than requiring the user to make this choice.
             It would then, however, deallocate the big population array
             straight away after the image rendering. 

   +         camera_module.f90/lines_compute_and_store_local_populations():
             The code now outputs which levels are being stored in a 
             big array. This is useful for debugging, in particular for
             the above planned automatic subset selection.

   +         lines_module.f90:
             Now add a new version of the lines_find_active_lines_levels()
             subroutine that also automatically selects a subset, and sets
             the active levels equal to that subset.

04.01.2012   lines_module.f90:
             Finished the lines_automatic_subset_selection() subroutine.
             This also automatically allocates the lines_levelpop() global
             level population array.

             camera_module.f90/camera_make_rect_image():
             I think I now also built it in correctly.

             I added a global flag "lines_autosubset" which, if set
             to .true., will make sure that camera_make_rect_image() will
             select the subset of levels on-the-fly.

  todo       But I notice that if you make a spectrum with aperture
             mode, then by default the images will be make again one-after-
             the-other, which again will make LVG extremely slow. Somehow
             I must be able to tell camera_make_rect_image() NOT to 
             recompute the populations.

  done...    OK, so in the one-after-the-other mode of making spectra
             I now calculate the populations beforehand, and set the
             lines_mode temporarily to 50 so that the imager will simply
             take the level populations as they are and will not 
             recompute them. This should avoid the above mentioned
             slowness.

  bug        In the one-image-at-a-time mode of the camera_make_spectrum()
             subroutine I reset the camera_frequencies(), but I init the
             camera before that. Presumably we'll anyway re-init the 
  fixed...   camara later, but still, better to fix this.

             I now added the command-line option:

                autosubset             

             which switches on the automatic subset selection.

             The code compiles again.

  bug        amr_module.f90:amr_regular_get_vertex_ixyz()
             I still had the wrong order of some statements, which
             I had already corrected in the amr_regular_get_ixyz()
             routine, but apparently forgot to correct in the
             amr_regular_get_vertex_ixyz() routine. That is now
  fixed...   fixed. I fixed it also in version 0.28.

  bug        lines_module.f90/lines_compute_velgradient()
             For the right boundary of the z-direction I mistakenly
             still had the if-statement if(izn.ge.1) then whereas
             it must be if(izn.le.amr_grid_nz) then. I did this
             correctly in the x- and y- directions, so it is simply
  fixed...   a typo. Fixed. I fixed it also in version 0.28.

             Note that I can also simply replace these lines with
             the line "else".

             It seems that the automatic subset method works! I 
             tested it for a very simple case (the 1-D LVG
             test model).

             [---> radmc-3d_v0.29_04.01.12.zip] 

  ++         I added the possibility of setting the autosubset
             option on in the radmc3d.inp file. 

             I think that this new autosubset mode should become
             standard. I see no reason why one would NOT want to
             have this. 
  &&&        ===> OK, it is from now on switched on by default.

             In the read_linedata() subroutine I now check that
             if the subset is selected by hand and the autosubset
             is switched on (which is the default), the code 
             stops. Thus: From now on, if you wish to manually
             select the subset, you MUST also explicitly switch
             off the autosubset, either with the "noautosubset" option
             on the command line, or by adding the line:
                lines_autosubset = 0
             in the radmc3d.inp file.

  !!!        There is still a problem: I want RADMC-3D in the
             autosubset mode to automatically figure out if
             the populations that have been calculated before
             are the same ones we need now. This would make
             making multiple images before quitting RADMC-3D
             much faster.

             OK, I now modified lines_automatic_subset_selection() such that
             it FIRST makes the selection (in the dummy_active_*** arrays
             that it locally allocates), and then checks if the selection is
             still the same, and if not, THEN redoes everything.

             The subroutine now returns the "redo" flag. If it is
             .true. then also the populations must be recomputed.

             So now what happens is that if the automatic subset selection
             is switched on, the code will check if the subset is still
             up-to-date. If so, and IF there exists the lines_levelpop()
             array, then it assumes that the populations have been computed
             for the current up-to-date subset.

             Hey, I realize that I should NOT allocate the lines_levelpop()
             array in the lines_automatic_subset_selection()
             subroutine. This should ALWAYS be done right before 
             the array is filled with values, so that whenever
             allocated(lines_levelpop) is .true. the values are
             also up-to-date.

             OK, that is also fixed. 

05.01.2012
    &&       lines_find_active_lines_levels():
             I now do not only check active levels and lines from the subset
             but from the full molecule, and check if they are all included
             in the subset. This way I can make a warning if a subset is
             selected that excludes lines that are in the current 
             frequency domain.

   &&&&&&    From now on the default lines_mode=1, i.e. LTE with storage
             of populations. It used to be lines_mode=-1, i.e. LTE with 
             on-the-fly populations. But since we now have the automatic
             subset selection by default switched on, there is not major
             reason to use on-the-fly populations. I will keep them 
             available, but I will gradually phase those on-the-fly 
             populations out. In particular, I will omit them from now
             on in the manual (only mention them as obsolete feature).

   &&&       I modified and updated the manual according to all these
             new rules and methods. 

             [---> radmc-3d_v0.29_05.01.12.zip] 

06.01.2012   amr_module.f90:
             Added special versions of amr_subbox_3d and amr_sample_3d
             for the case when we have not just nv but nv1,nv2 local
             data. This is necessary for the lines_levelpop().

   ++++      Added the possibility to make a subbox and/or sampling 
             of the level populations from the 3-D grid.

   &&&       The subbox output format has been modified a bit: I add
             a line containing the identities of the vector components.
             For outputting dust density or temperature this is trivial:
             it is always 1,2,3,4... (meaning component 1 is dust species
             1, component 2 is dust species 2). But for the level populations
             this is essential, because when subsets are used, it could 
             well be that only ilevel=4 and ilevel=9 are written. In 
             that case this identity list reads "4 9". 

             To mark this modification of the format, I raised the
             format number for subboxes to 2. I also did this for the
             sampling method.

             [---> radmc-3d_v0.29_06.01.12.zip] 

07.01.2012   lines_module.f90/lines_compute_velgradient()
 BUG         Instead of amr_regular_get_vertex_ixyz() it must be 
 Fixed       amr_regular_get_ixyz().

             [---> radmc-3d_v0.29_07.01.12.zip] 

29.01.2012   camera_module.f90/camera_serial_raytrace():

  BUGFIX     Forgot to set the bxc(1...3) values right after the
             amr_regular_get_ixyz()-call. This caused the code
             to get stuck when making SEDs for regular grids.

             Fixed.

06.02.2012   montecarlo_module.f90/walk_full_path_scat()

  BUGFIX     The variable "sint" was accidently declared as an
             integer instead of a double precision. That caused
             a wrong direction vector. It only showed up for
             when you put a star outside of the domain and the
             mc_weighted_photons is .true. (which is the default).

             Thanks, Erika Hamden, for reporting the bug.

             [---> radmc-3d_v0.29_05.02.12.zip] 

------------------------------------------------------------------------
At this point the development of version_0.31 was started, where the
Stokes parameters are introduced. But the development of version_0.29
and version_0.30 continues for the moment. All things introduced from 
this point onward, are also implemented in version_0.31
------------------------------------------------------------------------

28.02.2012   lines_module.f90/read_levelpop(action)
   bug       I accidently had '.inp' instead of '.dat' for the
             'levelpop_XXX.dat' files. The reason why it must be
             .dat is because it is a typical intermediate file.
   fixed     ---> Fixed.

   bug       lines_module.f90/read_lines_all()
             If lines_mode.eq.50 I did not read the gas temperature.
   fixed     That is wrong. ---> Fixed.

   ++++      Now the lines_mode.eq.50 mode of RADMC-3D seems to work,
             meaning that we can read in the level populations from
             file.

29.02.2012   camera_module.f90
   BUG       If no lines are automatically selected (because the 
             wavelength is not near a line), then the code crashes because
             lines_nrlevels_subset_max becomes 0.

   fixed     lines_compute_and_store_local_populations(action):
             If lines_nrlevels_subset_max is 0, the routine now 
             simply returns without doing anything.

01.03.2012   amrray_module.f90/amrray_find_next_location_cart()
  BUGFIX     In checking possible bizarre incidents, it is important
             to check if they are relevant, otherwise you might get
             into an infinite loop. So instead of

               if(dsx.eq.dsy) then
                  if((dsx.ne.1d99).and.(dsy.ne.1d99)) then

             we should have have

               if(dsx.eq.dsy) then
                  if((dsx.ne.1d99).and.(dsy.ne.1d99).and.(dsz.ge.dsx)) then

             and similar for the other two checks.

             This is now fixed. Thanks Stellar Offner for reporting the
             bug!

03.03.2012   amr_module.f90 and main.f90
  ++++       Adding the possibility to output VTK (Visual Tool Kit)
             files, for use in Paraview.

  BUG?       If I use amr_check_vertex(ivtx,x,y,z) on the amr-refined
             example model run_simple_1_userdef_refined, it crashes...

  Fixed      Now I check in the amr_check_vertex() routine if the cell
             points back to the vertex. If not, then we skip this.

  bug        rtglobal_module.f90/integer_to_string():
             For integers larger than 999 the formats were still I3 instead of
  fixed      I4 and higher. 

  ++++       The VTK output is now finished! Also a manual chapter is
             added about this new capabiity.

04.03.2012   
  problem    Doppler catching mode for saturated lines appears to cause
             overshoots (beyond the thermal saturation value) at the
             edges of the lines. This appears to violate Kirchhoff's law.
             Although I've tested this only for LVG mode. The problem
             appeared in the run run_lines_nlte_lvg_1d_1 when looking at it
             from incl=90 and phi=90 and when using in the problem_setup.pro
             a spatial resolution of nx=10 (very low resolution) and then
             using doppler catching.

             --> Not yet fixed. Need to look at this later.

  check!     When the number of pixels is very small in one or two of the 
             three dimensions, the spectrum-making perpendicular to that
             may be inaccurate. This happen in run_lines_nlte_lvg_1d_1 when
             looking at it from incl=90 and phi=90
             
             --> Not yet fixed. Need to look at this later.
             
06.03.2012   amr_module.f90 and main.f90
  &&&        I refined the VTK output a bit. Since Paraview cannot handle
             double precision numbers, I truncate numbers above 1d-30.
             For any density variable I now output the log10() of that
             variable. 

07.03.2012   Manual: I improved the images chapter, and added a figure to
             explain the definitions of the angles of the observer.

             I also added more tips to the warning of when your image has
             very extreme sub-pixeling. It gives the tip (for spherical
             coordinates) to increase the camera_min_drr variable.

             [-->radmc-3d_v0.29_07.03.12.zip]

==============================================================================
                           VERSION 0.30

Here the new binary format is introduced, using the new "stream" I/O
possibility in fortran2003. The g95 and gfortran compilers have this new
option also retroactively built in into their f90 and f95 fortran. As
far as I know, other compilers such as the intel fortran compiler also
support this.
==============================================================================

>>>> While working on a next version, implementing polarization, I noticed 
>>>> that there are major bugs in the small-angle scattering (which was    
>>>> never tested yet). I fix these now already in this (earlier) version.     
>>>> 01.03.2012   montecarlo_module.f90:
>>>>  MAJOR BUG   I used the dust_gfactor() array here, which is wrong, because
>>>>              we should use kappa_g(). 
>>>>   Fixed      This is now fixed, but it means that so far the anisotropic
>>>>              scattering was unreliable. 
>>>> 
>>>>  MAJOR BUG   In using the Henyey-Greenstein phase function I made a factor 
>>>>              of 2 mistake. This is because Phi(mu) = 2 P(mu) where P(mu) is
>>>>   Fixed      the probability function.


10.03.2012   I am working on the new stream I/O, which I call "binary".
             The files are therefore .binp, .bdat or .bout. 

  bug        amr_module.f90:
             The unformatted-style of amr_grid.inp uses normal integers
             while the other unformatted-style files all use 64-long
             integers.

  bug        amr_module.f90/amr_write_grid()
             In the part that writes the layer-style grid information
             the layer level was also written, but in the reading routine
             this was not read but computed. So the output was not
             consistent with the input. This is not a problem for most
             cases, because I think amr_write_grid() is hardly ever
  fixed      used. But I fixed it nonetheless.


 &&          amr_module.f90
             I removed the gridinfo stuff from the amr_grid.inp file.
             This was redundant information about e.g. the cell walls
             in an AMR grid - information that can be (and is usually)
             reconstructed automatically. It was only used for debugging.
             For normal use the gridinfo was not used anyway, so nothing
             should change for the user.

 !           In the C-style binary version of amr_grid.inp the "1" and
             "0" for the "leaf" or "oct-tree-branch" is written as
             kind=1 integer (byte) to save file size.

 &&          I removed the .usdat and .usinp and .usout format style: Now we
             will be able to choose between single-precision and
             double-precision in the C-style I/O by setting the second
             integer in the file to 4 (meaning normal single-precision =
             4-byte number) or 8 (meaning double precision = 8-byte number).

 &&          I reshape the complicated f77-unformatted storage of the
             level populations. This is the only thing that will be really
             changed in the way the unformatted stuff works.

 ++++        rtglobal_module.f90:
             I added a set of new routines that make it more standard
             how data is written and read:

              - read_scalarfield()
              - read_vectorfield()
              - write_scalarfield()
              - write_vectorfield()

 &&&&&       ioput_module.f90, lines_module.f90, montecarlo_module.f90,
             stars_module.f90:
             I completely rewrote the main I/O subroutines for the 
             main big data arrays. I now use the read_scalarfield(),
             write_scalarfield() and read_vectorfield(), write_vectorfield()
             subroutines. This makes the I/O routines a lot cleaner! And
             it made it easier to add the binary I/O option.

 !!!         The binary format I/O is now implemented, at least for the
             main datafiles.

 &&&&        montecarlo_module.f90:
             I made the mcscat_scatsrc(:,:,:) and mcscat_meanint(:,:)
             arrays back to double precision. Reason: this allows the
             use of the write_scalarfield() subroutine, without having
             to add yet more exceptions. Also: all other quantities are
             in double precision, too. 
             --> This causes the scattering self-test to fail, of course.
                 I checked, however, that the results are qualitatively
                 the same. I will now revert to the new version.

 !!          For the rest all self-tests are passed.

 &&          I also adapted the manual to explain, and put emphasis on,
             the new binary mode.

             For those who use compilers that do not support the
             access='stream' binary I/O, you can comment-out the
             open-statements that do this. Just make sure you do
             not use binary data then.

             Note that when we use access='stream' we must also use
             status='replace', because otherwise it won't delete the
             original file. 

             [-->radmc-3d_v0.30_12.03.12.zip]

 bugfix      idl/readradmc3d.pro
             Changed the read_data, so that it can read the new version
             of the mean_intensity.out output.

13.03.2012   examples/run_simple_1/
  ++         I added a demonstration of how to calculate J_nu (mean
             intensity). See README and the compute_radfield.pro file.
             I also tested that, for the optically thin case, the 
             results are as expected for a stellar point source.

  ++         examples/run_simple_1_binary/
             Added this directory as an example of the new binary 
             I/O method.

  fixes      Laszlo Szucs found a couple of errors in the manual and
             a couple of typos in the code. All fixed now.

             [-->radmc-3d_v0.30_13.03.12.zip]

 bugfix      idl/readradmc.pro
             Fixed a problem in the reading of amr_grid.binp.

  +          montecarlo_module.f90:
             Added a message about the scattering_mode used.

  +          camera_module.f90:
             Added a message about the nr of events per package for
             the scattering Monte Carlo.

 bug         montecarlo_module.f90/walk_cells_scat()
             There are two locations where the scattering source function
             and the mean intensity are updated. I think that in the first
             instance I still use the old method of computing the mean
             intensity via the scattering. In the second instance I do
             this better.
    fixed    I fixed this, and marked it with "BUGFIX 14.02.2012".
             It should not make much of a difference (actually hardly
             any), but it is more robust. 

 Tests       I have been playing with the anisotropic scattering now.
             The bugfix with the factor 1/2 in the Henyey-Greenstein
             function is already implemented. I did a couple of tests:

               - Use Henyey-Greenstein, but put g=0.00001 (not exactly
                 0, because otherwise RADMC-3D will automatically switch
                 back to scattering_mode=1). The scattering image looks
                 identical to that of isotropic scattering, as it should.
               - As you increase g, the image gradually starts to deviate
                 from the isotropic scattering case. 
               - Make a very optically thin cloud, so that multiple
                 scattering can be excluded. Then taking the "real" g
                 value of 0.8 clearly shows that the scattering halo is
                 more centrally concentrated. Exactly as it should. 
               - Go back to a low-but-non-negligible optical depth,
                 leading to roughly 0.3 scattering events per photon.
                 With g=0.8 and nphot_scat=100000 you now see strange
                 blips in the image. They vanish largely when you 
                 increase nphot_scat to 1000000. I suspect that the
                 origin is that because of the forward-peaking, the
                 chance that a photon package scatters *close* to the
                 line-of-sight (and thus contribute, with the forward-
                 peaked phase function, strongly to the scattering
                 source function) is rather low. But IF it does so,
                 then the forward-peakedness means that scattered
                 photon produces a strong contribution to the scattering
                 source function. 
               - Modify the code (in src_testscat/) to keep the Henyey-
                 Greenstein phase function for the scattering intact,
                 but use isotropic scattering for the random new photon
                 package direction. Result: the strange blips become
                 more numerous. This is consistent with the above 
                 picture, because now it is easier for a photon to
                 get scattered about 90 degrees close to the line-of-sight.
               - Modify the code (in src_testscat/) to make the 
                 contribution to the scattering source function isotropic,
                 but put the random-redirection of photon packages back
                 to Henyey-Greenstein. Result: the scattering halo
                 becomes larger. This is also as predicted: photons
                 are less hindered to get out, so they stay less long
                 close to the star. Hence the central-peakedness is 
                 reduced. 

             These tests are all just qualitative. But they do show
             that at least qualitatively the behavior appears to be
             consistent.

  +          opac/dust_continuum/bohrenhuffman
             I added a setup for the Bohren-Huffman code in the opac/
             directory. It is also a Mie code, like the code that is
             currently in the "jena/" directory. 


19.03.2012   dust_module.f90:
             Commented-out the find_dust_kappa() routine, as it is no longer
             used.

             [-->radmc-3d_v0.30_19.03.12.zip]

==============================================================================
                              VERSION 0.31

Here I will build in a genuine 2-D cartesian (pencil-parallel) and 
1-D cartesian (plane-parallel) mode.
==============================================================================

19.03.2012   The 1-D and 2-D cartesian modes are very different from the
             usual modes. They are also very different from the 1-D and
             2-D spherical modes, since in spherical coordinates they still
             represent a finite 3-D object. The 1-D and 2-D cartesian modes
             represent infinite slabs. In principle one could emulate these
             using strongly zoomed-in spherical coordinate setups, but that
             is clunky. 

             So we now introduce igrid_coord = 10, which is the 1-D
             cartesian mode and igrid_coord = 20, which is the 2-D cartesian
             mode.  In the 1-D cartesian mode, both y- and z- directions
             must be infinite size, while in the 2-D cartesian mode, only
             the z-direction is infinite.

             You can switch on the 1-D mode by setting the ydim and zdim to 0,
             and by setting the yi=[-1d90,1d90] and zi=[-1d90,1d90]. Internally
             RADMC-3D will then set igrid_coord to 10 resp. 20.

             Changes made in:
             ioput_module.f90
               When reading the grid, the new coordinate system can be 
               selected. 
             stars_module.f90
               In the new coordinate system, stars are no longer allowed.
               Instead use illum.inp.

     +++     Adding optional thermal boundaries, which is useful for 1-D models.
             I decided to implement this in a general way, for cartesian
             coordinates. You can switch each boundary on in the radmc3d.inp
             file, e.g.:

               thermal_boundary_xl = 30.

             meaning that the left-x-boundary will be a thermal boundary
             with a temperature of 30 K.

             Changes made in:
             rtglobal_module.f90
               Added thermal_bc_active(2,3) and thermal_bc_temp(1:2,1:3)
             camera_module.f90
               Whenever the ray enters the grid in cartesian coordinates,
               and if the thermal boundary is activated, the intensity
               will be replaced by the planck function at that temperature.
               Note that, see from the other side, the boundary is transparent!
             montecarlo_module.f90
               This was a lot of work: Added mc_cumlum5 and an extra 
               luminosity source type, an extra energy (for the weighted
               photon scheme) etc.

             It compiles. The self-test is succesful.

   bug       The code stops when no stars are included. This should not
             happen if we have other sources of light, such as thermal
   fixed     boundaries. Fixed.

             OK, it passes the self-test, and I can switch on the new mode.

             A first test with the thermal boundary yields a result that
             initially surprised me. The higher the optical depth, the more
             the temperature away from the boundary decreases. In hindsight
             this can be easily understood, because any photons that find
             their way back to the thermal boundary and get absorbed are, in
             fact, killed.

             Now I did a test with all 6 boundaries closed, all at 100 K. 
             The result should be that the temperature everywhere is
             100 K. At first I got a strange edge-effect, but that was
             because I did 

               ray_cart_x    = amr_grid_xi(amr_grid_nx,1)-epsdist

             but it has to be

               ray_cart_x    = amr_grid_xi(amr_grid_nx+1,1)-epsdist

             With this fixed, the dust temperature is indeed nicely
             100 K everywhere. Test passed!

             Let's make a new zip archive:

             [-->radmc-3d_v0.31_20.03.12.zip]

             Working on the manual to include the new stuff.

  TODO       NOTE: I still have to include the illumination beams
             for the plane-parallel case.

             run_1dpp_dust is an example model for the 1-D plane-parallel
             mode.

             [-->radmc-3d_v0.31_20.03.12_a.zip]

21.03.2012   
  &          stars_module.f90:
             In this module the star_lum(istar) is calculated, but this is
             anyway overwritten in the montecarlo_module.f90. It is therefore
             confusing that it is here computed without use. I therefore 
             commented this out in the stars_module.f90 and replaced it
             with setting it to -1d90, to force an error if it is used
             somehow nonetheless.

  ++         Added the illuminating beam fluxes, to replace the stars
             in the 1-D plane-parallel case. 

  &&         ioput_module.f90/read_grid_file():
             I added igrid_coord = amr_coordsystem, so that the 
             read_stars() routine can already use this.

             --> The illuminating beams work! They are now added to the
                 run_1dpp_dust/ example model.

             [-->radmc-3d_v0.31_21.03.12_0.zip]

21.03.2012   Attila Juhasz has improved the VTK mode! I will now merge
             that into the current version...
             --> DONE.

   BUGFIX    amr_module.f90:
             Attila Juhasz found and corrected a set of really subtle bugs in
             the self-check of the vertices for the case of cyclic phi in
             spherical coordinates. Example:
                  if(y.ne.amr_finegrid_xi(a%ixyzf(2)+1+amr_ydim-iy,1,a%level)) then
             must be (and is corrected by Attila):
                  if(y.ne.amr_finegrid_xi(a%ixyzf(2)+1+amr_ydim-iy,2,a%level)) then
             --> DONE.

             [-->radmc-3d_v0.31_21.03.12.zip]

==============================================================================
                              VERSION 0.32

Now build in Stokes parameters.
==============================================================================

22.03.2012   
   +++       I added polarization_module.f90 to RADMC-3D. This is a 
             module that was developed from a set of subroutines
             that were designed by Michiel Min. Thanks, Michiel, for
             providing these subroutines!

             Now we have to replace a number of things with their 
             Stokes parameter version. For instance, the I --->
             (I,Q,U,V), but also the source functions. 

             montecarlo_module.f90, camera_modue.f90:
             First task: replace mcscat_scatsrc() with mcscat_scatsrc_iquv.
             The 1:4 indices are added to the right, so that they 
             represent the outermost index. Tests show that array
             access of an array a(i,j,1,1) is equally fast as a(i,j),
             i.e. adding indices to the outermost part does not matter
             for the speed, if you index the arrays with constant
             indices. With variable indices, k=1, l=1, a(i,j,k,l) it 
             is a bit slower, but only marginally so. But if we add
             the indices at the inner part: a(1,1,i,j) that is much
             slower. So we add the 1:4 index to the outer part.

             In the process, we also move the 1:nrdirs index to the
             outer part. 

             This was succesful.

             camera_module.f90
             Change camera_intensity into camera_intensity_iquv.
             Change camera_rect_image into camera_rect_image_iquv.
             Change camera_spectrum into camera_spectrum_iquv
             Change backup_spectrum into backup_spectrum_iquv

             dust_module.f90
             Added the stuff for the polarized scattering.

             Now I've got everything implemented that I had in the
             shelved version. 

             It compiles and passes the self-test.

             However, currently the "wires are not yet connected"
             for the polarization to work. For this, quite a bit
             more has to be done, for which I currently do not yet
             have time. 

             [-->radmc-3d_v0.32_22.03.12.zip]

27.03.2012   rtglobal_module.f90, lines_module.f90:
             I repaired the backward compatibility of the f77-unformatted
             gas_velocity.inp format.

29.03.2012   camera_module.f90/lines_compute_and_store_local_populations()
  BUGFIX     The pop() array must be a 2-D array, with also ispec as an
             index...

14.05.2012   camera_module.f90
  bug        There is still this annoying bug that in spherical coordinates,
             if the inclination for an image or spectrum is 0, the code 
             crashes. This is simply because then the equations become 
             singular. Maybe I should catch this and put the inclination to
             a tiny number.

             The problem only appears if (a) you make a spectrum or
             (b) you choose an odd number of pixels.

  partially  Instead of making a SED or spectrum with a 1x1 pixel image, I now
  fixed      make a 2x2 pixel image (of course with subpixeling). That should
             essentially solve the problem and should produce the identical
             result as the 1x1 pixel method, because the subpixeling would
             anyway refine the 1x1 image at least into a 2x2 image.

15.05.2012   ---> Seems to work, and give the same result as version 0.29,
                  but now does not crash anymore for the case of incl=0

16.05.2012   montecarlo_module.f90:
 bug         walk_full_path_bjorkmanwood() and walk_full_path_scat():
             If mirror symmetry was switched on, and one places a star at
             the equator outside the grid domain, the direction of the
             radiation was not ensured to be upward.\
 fixed!      I now placed the if(igrid_mirror.eq.1) then statement outside
             of the if(star_fraclum(istar).eq.1.d0) then statement, and now
             it works! 
             Thanks, Richard Pearson, for reporting this!

16.05.2012   amr_module.f90:
 BUG         In the VTK output there was a bug. The line

                 form='(A6,A'//trim(slen)//',1X,A6,1X,A'//trim(slen2)//')'

             must be

                 form='(A6,A'//trim(slen)//',1X,A'//trim(slen2)//')'

 fixed       Thanks to Peter Schilke for reporting and fixing this!

             [-->radmc-3d_v0.32_17.05.12.zip]

==============================================================================
                              VERSION 0.33

Now remove the anu_base and jnu_base and replace with nup and ndown.
==============================================================================

17.05.2012   So far the methods for integrating the line transfer equation
             with second order integration had the problem that for cases
             of masering the method was unstable. 

             I now replaced all instances of jbase and alpbase with the
             nup and ndown. Now the jbase and alpbase will be computed
             at the same point where the line profile is computed: on-the-fly
             during the ray-tracing. The hope is that this change the
             doppler catching method will then automatically also handle
             the masering better. 

             [--> backup_1.zip]

             I have not yet tested it, but it compiles without problems.
             
             [--> radmc-3d_v0.33_18.05.12.zip]


             Further migration from camera_module to sources_module. Some
             things go wrong now... No time to work on this now.

20.05.2012   
  &&&&&      examples/*

             I replaced the dustkappa_silicate.inp in most of the 
             example models with a version that has a larger wavelength
             range. Until version 0.30 the wavelength range was only
             up to 200 microns. Now it does to 1d4 microns, although
             of course the long wavelength parts are extrapolated,
             so please don't trust those opacities blindly!

   &&        opac/dust_continuum/jena/makedust.F
             I changed the way the interpolation of the optical constants
             is done. This avoids this strange wiggle between 200 and 500
             micron in the opacity. 

02.06.2012   sources_module.f90 and camera_module.f90

             So the goal is to migrate all stuff from the camera_module.f90
             that has to do with the sources into the sources_module.f90, so
             that it can also be used by the lambda operator.

             Most changes are in the sources_module.f90 and the
             camera_module.f90, but also some small modifications in
             main.f90 and montecarlo_module.f90 (the
             camera_mcscat_monochromatic flag is moved there).

             Note: At the moment the second order integration is not
             yet available in local observer mode. That must be changed...

             OK, so the move of stuff to the sources_module is finished, and
             the stuff compiles. The only unelegant thing is, still, that
             the names of a lot of variables and arrays in the
             sources_module still have the camera_ prefix.

             [--> backup_1.zip]

             Now do the name changes of these variables to sources_***.
             Done. And it compiles again.

             [--> backup_2.zip]

             Now make a source_frequencies(:) array, which, for any 
             camera actions, should be a copy of the camera_frequencies(:)
             array. Reason for the sources_frequencies(:): if we wish to
             use the sources_module for the lambda operator, it should
             be completely independent of the camera_module... Right now
             the camera_frequencies(:) array is in the rtglobal_module.f90.
             But that should go back to the camera_module.

             Makefile:
             I also had to change the order of the compilation a bit, to
             assure the userdef_module is compiled before sources_module
             which is compiled before camera_module. Now it works.

             Done! It compiles.

             [--> backup_3.zip]

             examples/run_simple_1_userdef* 
             I had to update the Makefiles in these directories.

             Passed the self-test...

             [---> radmc-3d_v0.33_02.06.12.zip]

             rtglobal_module.f90:
      +      Added polarization_mode and ray_cart_svec(1:3).

             camera_module.f90/camera_set_ray():
      +      Added setting the svector

             main.f90/read_radmcinp_file()
      +      Added the possibility to set polarization_mode value. 
             Also set the default to 0.

             camera_module.f90/camera_compute_one_pixel()
      &      intensity(nrfreq) ---> intensity(nrfreq,1:4)

             So much for today. Still to do:

              - camera_serial_raytrace(): intensity(nrfreq) ---> intensity(nrfreq,1:4)
              - get_src_alp: add iquv to src and alp. Put all these
                components first to zero.  Note that for scattering off
                randomly oriented particles the alpha will be the same for
                all Stokes parameters, but for thermal emission from aligned
                grains this is not so. In fact, there it will be more
                difficult: We would have to either use a full matrix or the
                alternative Stokes definition...  *** STILL TO THINK ABOUT ***
              - montecarlo_module: add scat pol stuff into scatsrc
              - ? Add stokes dim to secondorder stuff. Find a good way to interpol only if necessary. 

             [--> backup_4.zip]

03.06.2012   amr_module.f90
   bugfix    Pak Shing Li (Berkeley) found the following bug: Original:
                  levelmax   = amr_layers_nrtot 
             must be:
                  levelmax   = amr_layers_nrlevels
             Fixed this now. Thanks, Pak Shing Li! 

05.06.2012   lines_module.f90
   ...       I profiled the lines_solve_statequil() subroutine and found that
             the code spends too much time here. I think that I know why...
             The way that the matrix is filled is inefficient: it is done
             row-by-row. Instead, it would be more efficient to do it 
             transition-by-transition. Improving this is not a high priority,
             but should be done at some point.

09.06.2012   montecarlo_module.f90/montecarlo_random_pos_in_cell()
             I removed the argument params from the argument list. 

18.06.2012   TODO for the line transfer:
              - Improve the filling of the statistical equilibrium matrix
              - Allow to solve only a subset of levels (for cold gas)

01.07.2012   Thinking about adding escape probability to RADMC-3D line mode.
             To do it really right, it would be important also to include
             the local continuum (in the source function) as well as the
             external continuum (from the dust Monte Carlo code). The line
             source function then is no longer frequency-independent. 
             This all becomes a bit complex, but doable. 

             However, for now let us do this much simpler. Let us ignore
             continuum, ignore external pumping etc. Just add the escape
             probability. This must be an integral over the line profile:

                          /
                 J_line = | phi(nu) J_nu dnu 
                          /

                 J_nu   = (1-beta_nu)*S_nu + beta_nu*J_nu^bg

             For the case without continuum the S_nu = constant = S_line,
             and we assume that J_nu^bg is nearly constant over the line:

                 J_nu   = (1-beta_nu)*S_line + beta_nu*J^bg

             The line-integrated mean intensity is then

                 J_line = (1-beta_line)*S_line + beta_line*J^bg

             with

                             /
                 beta_line = | beta_nu phi(nu) dnu
                             /

             (which is only valid for the case without continuum).

             The beta_nu is the frequency-dependent escape probability,
             which also depends on the line profile:

                           1 - exp(-tau_nu)
                 beta_nu = ----------------
                               tau_nu

             with
                                  h nu
                 tau_nu = N_mol * ---- * ( n_d B_du - n_u B_ud ) * phi(nu)
                                  4 pi

             For the case without continuum and with a simple Gaussian line
             profile it is therefore possible to pre-compute beta_line as a
             function of the line-center opticap depth and tabulate this.
             
             ====> It turns out that the resulting beta_line is roughly
                   the same as the freq-dependent version:  

                   beta_line =~ (1-exp(-0.5*tau_line)) / (0.5*tau_line)

                   In other words: the line wing escape is not very 
                   important for the case of a Gaussian line profile.

             Conclusion: Let us stick to an even simpler recipe: just
             take beta_line = (1-exp(-tau))/tau, where tau is the line
             center optical depth. This is what also van der Tak et al.
             2007 A&A 468, 627 use. 

  bug?       lines_module.f90/lines_compute_lvgpop()
             I notice that the van der Tak formula is used twice; the
             second time appears to be an "orphan", i.e. not used 
             anymore. I will comment it out.

  bug        lines_module.f90/lines_compute_lvgpop()
             The LVG would crash if the velocity gradient is 0 somewhere.
  fixed      Now I fixed this by adding 1d-90: ( velgrad + 1d-90 ).
             
  ++         lines_module.f90/lines_compute_lvgpop()
             I added the possibility of adding a maximum length scale.
             This acts as an escape probability. I use the above simplest
             version of escape probability. 

  ++         lines_module.f90
             I added the read_escprob_lengthscale(action) subroutine and
             the lines_escprob_lengthscale(:) array.

  ++         sources_module.f90
             If in the LVG mode the lines_escprob_lengthscale(:) array
             is found, then it will include this in the LVG populations.

             ----> It compiles. Not yet tested!

             [--> radmc-3d_v0.33_01.07.12.zip]

01.07.2012   main.f90 and lines_module.f90:
             lines_nonlte_maxiter default is now set to 30 (instead of 10).

             Testing the LVG + esc prob...

  IMPORTANT: The LVG and Escape Probability method still do not converge
  TODO       well for extreme problems. This is simple to fix, using the
             same trick as in ALI, but this still has to be done.

  BUG        lines_module.f90/lines_compute_lvgpop():
             For small tau the beta must be computed using a Taylor
  FIXED      expansion: beta = 1.d0 - 0.5d0*tau + tau**2 / 6.d0.
             This is now done (for tau < 1d-5).

             [--> radmc-3d_v0.33_02.07.12.zip]

02.07.2012   lines_module.f90/lines_solve_statequil()
   &&&       Major improvement of the matrix filling for the statistical
             equilibrium equations. Instead of going equation-by-equation
             we now go line-by-line, thus filling up the matrix. This 
             removes essentially one loop with if-statements. Much faster.

             The new version with both lines_solve_statequil() and 
             lines_solve_statequil_old() is now copied to: 

                ---> lines_module.f90_oldnew

             Now I remove the old subroutine lines_solve_statequil_old().

             [--> radmc-3d_v0.33_02.07.12_b.zip]

02.07.2012   lines_module.f90/lines_compute_lvgpop()
  &&&&&&     MAJOR improvement of the LVG + EscProb method: instead of
             literally iterating like Lambda Iteration I now multiply
             the A_ud with beta_ud and replace Jbar_ud with only the 
             external part (e.g. the cosmic bg radiation). This should
             converge much faster.

             Test: Yes, it reproduces the same results, with only 2
             iterations!

             I put the lines_nonlte_maxiter default back to 10.

             [--> radmc-3d_v0.33_02.07.12_c.zip]

01.08.2012   lines_module.f90/lines_compute_lvgpop()
             Rahul appears to get problems with this new mode. The
             iteration does not converge. Maybe this is because of
             the >1d-30 limitation that it is then no longer 
             normalized..? I'll renormalize it and see.---> Does
             not help.

             I checked: it seems that it reaches a flipflopping
             state. I saw that Rahul had implemented 
             lines_Tex(iline) = 0.5*( lines_Tex(iline)+newTex ),
             so I guess he found a similar problem. So let us
             build this in too, but for the level populations.

   ++        lines_module.f90/lines_compute_lvgpop()
             Implemented the slowing-down parameter for the LVG iteration to
             avoid flipflopping. That seems to work! It indeed no longer
             flipflops.

             I am still not happy with this, because it always slows it
             down, rather than slowing it down when a flipflopping is going
             to happen. But let's zip this version for now.

             [--> radmc-3d_v0.33_01.08.12_a.zip]

             Now let us implement an "average number of iterations"
             counter, so that RADMC-3D can report how many of these
             iterations are done. If things are slow, at least we
             know why. 

   ++        ---> Done

             [--> radmc-3d_v0.33_01.08.12_b.zip]

             I now implement the anti-flipflopping method. The idea is the
             following. We have, in addition to levelpopold also
             levelpopold2. If we see that in any of the levels
             (levelpop-levelpopold)*(levelpopold-levelpopold2) < 0, then we
             implement the slowdown. Else not.

   ++        ---> Done, and it works like a dream!! Instead of 40 iterations
                  we now have only 6 iterations on average.

             [--> radmc-3d_v0.33_01.08.12_c.zip]

             Also let's implement a check if all populations above
             some energy are <<1, in which case too many levels are
             included. This is not a problem, but a cause for slow-down.

             ---> Done, using 1E-15 for the fractional population as the
                  threshold for "as good as empty"

             I think we can now wrap this up as the real v0.33_01.08.12:

             [--> radmc-3d_v0.33_01.08.12.zip]

02.08.2012   sources_module.f90/sources_init():
   bugfix    Changing:
               if((iinu.lt.0).or.(iinu.gt.freq_nr)) then
             into:
               if((iinu.lt.1).or.(iinu.gt.freq_nr)) then

             montecarlo_module.f90/montecarlo_compute_freqdep_luminosities()
   bugfix    Changing:
                 ( (1-eps) * mc_stellarsrc_templates(inu,itemplate) +          &
                       eps * mc_stellarsrc_templates(inu+1,itemplate) )
             into
                 ( (1-eps) * stellarsrc_templates(inu,itemplate) +          &
                       eps * stellarsrc_templates(inu+1,itemplate) )

             Thanks, Kevin Sooley, for pointing out these bugs to me and
             for testing the smooth stellar source mode of RADMC-3D!

             [--> radmc-3d_v0.33_02.08.12.zip]

04.08.2012   
  bugfix     sources_module.f90/sources_init():
               call hunt(freq_nu,freq_nr,sources_frequencies(inu),iinu)
               if((iinu.lt.1).or.(iinu.gt.freq_nr)) then
             replace the second line with:
               if((iinu.lt.1).or.(iinu.ge.freq_nr)) then
             In other words: I had made TWO errors in the same line...

  bugfix     stars_module.f90/read_stellarsource(action)
             Replace
               allocate(stellarsrc_lumcum(1:nrcells),STAT=ierr)
             with
               allocate(stellarsrc_lumcum(1:nrcells+1),STAT=ierr)

             Again thanks, Kevin Sooley, for the bug reports.

             [--> radmc-3d_v0.33_04.08.12.zip]

==============================================================================
                              VERSION 0.34

Finally let us build in the Modified Random Walk (MRW) of Min et al. 2009. 
Should have done so ages ago, but there was always something of higher
priority.
==============================================================================

23.08.2012   montecarlo_module.f90:
             First let us get rid of the "optimized motion" stuff. I 
             never used it, and it will become obsolete once we build
             in the MRW.

             Done:  ---> montecarlo_module.f90_5

  bug?       I note that with the ifast==1 method (when we only recalculate
             the dust temperature if the energy has increased by more than
             some percentage) there might be a bug:

              if(abs((mc_cumulener(ispec,ray_index)+mc_enerpart(ispec))/      &
                      mc_cumulener_bk(ispec,ray_index)-1.d0)                  &
                      .gt.params%enthres) then

             Shouldn't this be:

              if(abs((mc_cumulener(ispec,ray_index)+mc_enerpart(ispec))/      &
                      (mc_cumulener_bk(ispec,ray_index)+1d-99)-1.d0)          &
                      .gt.params%enthres) then

             to avoid INF or NAN if mc_cumulener_bk(ispec,ray_index).eq.0?
             Since I never use ifast, I never noticed. I also do not know if
             this is a problem or not.

  fixed      Fixed.  ---> montecarlo_module.f90_6

     !       I also noticed that I always allocate the mc_cumulener_bk()
             array, even though it is only used if ifast.gt.0 (which so
             far is rarely used). Also, I noticed that in case of 
             temperature coupling, the same dust-species-separated
             array is used, whereas that appears to be not necessary
             (one could use a single energy for the sum of all species).

     &&      I changed, in do_absorption_event():

               if(calctemp) then

             to

               if(calctemp.and.(params%ifast.ne.0)) then

             Now the mc_cumulener_bk() is truly only used if ifast.ne.0.
             I also now changed:

                      allocate(mc_cumulener_bk(1:dust_nr_species,1:nrcellsmax),STAT=ierr)
                      ...

             into 

                  if(params%ifast.ne.0) then
                      allocate(mc_cumulener_bk(1:dust_nr_species,1:nrcellsmax),STAT=ierr)
                      ...
                  endif

             So now it is no longer allocated if not necessary.

             ---> montecarlo_module.f90_7

   &         montecarlo_module.f90/compute_dusttemp_coupled_bd()
             I changed the argument list of this subroutine. Now
             we do not hand over all the energies of all the dust
             species, but only the total sum. This way we can
             use this subroutine also for the MRW.

  bug?       I found:

                do ispec=1,dust_nr_species
                   tempav = compute_dusttemp_coupled_bd(dust_nr_species,       &
                                   mc_cumulener(1,ray_index),                  &
                                   dustdens(1,ray_index),cellvolume(ray_index))
                   dusttemp(ispec,ray_index) = tempav
                enddo

             Seems like overkill to me. Should be possible to write this
             as:

                tempav = compute_dusttemp_coupled_bd(dust_nr_species,       &
                                mc_cumulener(1,ray_index),                  &
                                dustdens(1,ray_index),cellvolume(ray_index))
                do ispec=1,dust_nr_species
                   dusttemp(ispec,ray_index) = tempav
                enddo

             Result is the same, but it is faster and not so confusing.
             ==> Done. And immediately changed mc_cumulener(1,ray_index) 
                       to entotal.

             ---> montecarlo_module.f90_8

24.08.2012   amrray_module.f90
 BUG??       I found the following strange thing in the amrray_module.f90:

               !
               ! Exception handling
               !
               if(theta2.eq.pi) then
                  amrray_finegrid_sintsq2(i,ilevel) = 0.d0
                  amrray_finegrid_costsq2(i,ilevel) = -1.d0
               endif
             
             How can the cosine(t)^2 be -1 ?? I think that this is a
             mistake. Strange that this never caused a problem...

             I was contemplating to introduce also the sint2 instead
             of sintsq2 arrays for use with the MRW, but in testing
             the MRW routines externally I noticed that the pre-
             computation of these cosines and sines did not speed up
             the subroutines in any measurable way. That is apparently
             not the bottleneck. So let's just compute them on-the-fly.

24.08.2012
   +++       montecarlo_module.f90:
             I am working on the implementation of the MRW method. This is
             not entirely trivial to do well, because I want to prevent
             having to recalculate the Planck and Rosseland mean opacities
             each time a photon enters a cell. That would be too slow.
             So I want to store them in a big array, and only update if
             the energy of that cell has exceeded the previous energy
             (when the opacities were calculated the previous time) by
             some percentage. This is not difficult, but it requires a
             bit of bookkeeping. 

             - Added array allocations mrw_cumulener_bk etc.
             - Added some code in walk_full_path_bjorkmanwood() for MRW
             - Added a counter and index_prev

             ---> montecarlo_module.f90_9

  Question:  For cartesian coordinates I always assume that the cell is
             3-D, and in the MRW I have no separate 2-D or 1-D mode
             for that. On the other hand, I recently introduced the
             2-D and 1-D slab geometries in cartesian coordinates.
             Will they conflict?

             I think it will be good to memorize which cell is earmarked
             for MRW. Once a cell has been earmarked for MRW, then we
             will not need to count a minimal number of "events" inside
             this single cell before going on to check out the possibility
             for MRW. We then go straight for the check if MRW is possible.

             So, add a logical array.

             ---> montecarlo_module.f90_10

             From here on I thought I was smart and introduced 
             an array mrw_cumulener(). But I realized that that
             was not very smart because I need the mc_cumulener()
             array anyway, even if we use MRW... So:

             ---> montecarlo_module.f90_11_dropped

             Back to montecarlo_module.f90_10

             Reinsert some of the stuff I did between _10 and _11_dropped
             that was ok.

             ---> montecarlo_module.f90_12

             I fear that there is no other way than to store the Planck mean
             opacities for all dust species separately. This way it would be
             easy to split the gained energy back into the per-species
             mc_cumulener() array. We could also keep open the option 
             to not store the mean opacities, to save memory, if necessary.
             But for now let us do it with storage.

             So I have now split the alpha_a_pm into alpha_a_pm(1:dust_nr_species)
             and mrw_alpha_abs_planck(1:nrcells) into 
             mrw_alpha_abs_planck(1:dust_nr_species,1:nrcells). 

             ---> montecarlo_module.f90_13

             For today I leave it at this point. UNFINISHED!

             [---> radmc-3d_v0.34_24.08.12_unfinished.zip]             

25.08.2012   OK, I think I know a possible solution for avoiding the storage
             of all the Planck mean opacities for all species: Store the
             planck mean kappas for each species as a table as a function of
             temperature.  We cannot do this for the Rosseland mean
             opacities, but we CAN do this for the Planck mean opacities!
             That would mean that we only need to precalculate these tables
             and then do a look-up for a given temperature.

             I have now implemented the Planck opacity database and
             retrieval subroutine.

             ---> montecarlo_module.f90_14

             I have now implemented how the Planck opacities are used, and I
             have implemented the slight backtracking of the MRW subroutine
             so that it stops just short of the edge of the cell. This
             allows the normal walk_cells subroutines to do their job in
             finding the next cell.

             ---> montecarlo_module.f90_15

             I realized that it would be even better to calculate and store
             Rosseland mean opacities at two temperatures, and do a linear
             interpolation between them. That would be (a) more accurate and
             (b) allow for calculating the Rosseland mean opacity only every
             factor of 2 in temperature, for instance, which would save even
             more time. But I decide for now to wait with this until I
             finish the first installation of the MRW. Maybe it is not even
             the main bottleneck, in which case it would be a waste of time
             to implement it. 

             Now I added most that remained to be added to the 
             walk_full_path_bjorkmanwood() subroutine, with the exception
             of the Rosseland mean opacity calculation routine.

             ---> montecarlo_module.f90_16

 STILL TODO  I still have to build in a way to calculate the escape fraction
             by unlikely but possible long-wavelength low optical depth 
             escape. Not yet done.

 TO CHECK    For the computation of the Rosseland mean opacity we
             use kappa_abs + (1-g)*kappa_scat. The g is taken from
             kappa_g(inu,ispec), which was found by calling
             find_dust_kappa_interpol(mc_frequencies(inu),ispec,temp,0,0,1)
             in the montecarlo_init() subroutine. But I must check that this
             value is also correctly computed if the scattering phase
             function is tabulated instead of a Henyey-Greenstein function.

   bug       I noticed that in the above versions I forgot to include the
             *freq_dnu(inu) multiplication in the Planck Mean opacity 
             calculation. Fortunately I spotted this.

             I now also implemented the Rosseland mean opacity subroutine.

             ---> montecarlo_module.f90_17

             I have not yet compiled. That's for tomorrow.

             [---> radmc-3d_v0.34_25.08.12_unfinished.zip]

26.08.2012   montecarlo_module.f90
             I now fixed the last few things; now it compiles.

             ---> montecarlo_module.f90_18

             I noticed that if we indeed recalculate the mean opacity
             every factor (1+enthres) of energy, then in the beginning
             (energy=0) we recalculate it infinitely many times. To
             avoid this, I introduced mrw_tempthres=3.0, meaning that
             below 3K there will be no stopping of the MRW to recalculate
             the mean opacities.

     !       A good check could be to test if the temperatures of
             a multi-species dust model setup are indeed the same
             in very optically thick cells.

             For the picking of the random frequency I introduce a
             new array: dcumen, which is just the difference between
             the energy of the cell after and before the MRW, for
             each dust species.

             ---> montecarlo_module.f90_19

             First test: nothing improves... OK, so something must
             be going wrong. Let's figure this out. I see: It is
             because I chose the mrw_tauthres=100, which is not
             reached.

    +        I want to keep track of the average nr of times a
             photon revisits the same cell. So I put the increasing
             of the count_samecell counter outside of the MRW
             stuff, so that it is always done. 

             ---> montecarlo_module.f90_20

             I noticed that you often still get a low value, and I think I
             know why: I should weigh the nr of revisits in each cell by the
             number 1+revisits itself, because that is where most of the CPU
             time is spent.

             Also I moved the counting upward, just below the call to
             walk_cells_thermal().

             ---> montecarlo_module.f90_21

             OK, bug found! I also reset the counter at a wrong point
             (after checking for the fourth MRW criterion). Should not
             do this. Fixed.

             ---> montecarlo_module.f90_22

             Some more fine-tuning after some testing...

             ---> montecarlo_module.f90_23

             But I fear that at the moment the MRW makes it slower
             by a big factor... So something is still very wrong!

             However, for now, let's zip it...

             [---> radmc-3d_v0.34_26.08.12_unfinished.zip]

             AH! I know where the problem lies: I have to copy
             the pos() and dir() back to the ray_cart_**.

             ---> montecarlo_module.f90_24

             OK, now it works, and it is indeed fast! The one-cell
             test gives a slightly lower temperature, but still
             very good (256 K instead of 270 K). More testing in
             the coming days...

        bug  Still found a bug: out of cell. I think that it can
             happen in rare cases that if you retract by ds_margin
             from the wall, but if ds_margin.gt.dscross, then you
             might retract so far as to exit the cell on the other 
             side. This could happen if you are close to a corner.
             So I prevented the ds_margin to be larger than dscross.

             OK, now it works. But the temperature that comes out in the
             modified version of run_simple_1 (i.e. run_test_1) is a bit
             higher than that of the original model.  I wonder whether this
             is because of the fact that the MRW method does not deal with
             long-wavelength escape. By using the MRW method you
             intrinsically assume to be in the diffusion limit. But in
             reality every now and then a photon can escape by simply being
             emitted at long enough wavelength. I've described this "leakage
             cooling" in my own paper with Gerd-Jan van Zadelhoff and
             Antonella Natta many years ago. I am not sure how to 
             deal with this here. 

             [---> radmc-3d_v0.34_26.08.12.zip]

30.08.2012   main.f90, lines_module.f90
   bug       I made a bug in the parsing of the line_profile argument.
             --> Fixed.

     ----> STILL CONTINUING TESTING OF THE MRW METHOD... BUT IN THE MEAN
           TIME: V0.35

==============================================================================
                              VERSION 0.35

Now let us continue building in the Z-matrix for scattering.
==============================================================================

31.08.2012   polarization_module.f90, dust_module.f90:
    +        Added the computation of g == <mu>, so that g is always
             available, even in cases where we do not use Henyey-Greenstein
             but instead use tabulated Z-coefficients.

    +        polarization_module.f90:
             Added subroutine polarization_make_s_vector(n,s).

             I now decided that

               scattering_mode = 4  ---> polarization included, but 
                                         only for the scattering
                                         source function and thus
                                         for images and spectra.

               scattering_mode = 5  ---> polarization included, 
                                         everywhere: In the Monte
                                         Carlo as well as the 
                                         imaging and spectra.

             For the moment let us first build in scattering_mode 4.
             So that means that we do not yet have to include this
             in the Monte Carlo, except in the updating of the
             scattering source function.

    +        monteacarlo_module.f90:
             Working on the implementation of the polarized scattering
             source function. In addition to the mcscat_dirs, we also need
             mcscat_svec.

             ---> IN THE MIDDLE OF THE IMPLEMENTATION...

01.09.2012   montecarlo_module.f90:
             We have to add the arrays for the Z-matrix elements into
             the MC module, just like we made the kappa_a() etc arrays.
             This prevents us from having to do bilinear interpolations
             on-the-fly. 

     +       rtglobal_module.f90:
             This, however, also requires us to allocate an array
             scat_mui_grid() and read in a file
             "scattering_angular_grid.inp"... This will contain:
               nr of mu points
               nr of phi points
               mu grid
             It will not contain a phi-grid, because we will always assume
             that the phi-grid is linearly spaced. 
             ---> Done.

     --      dust_module.f90:
             I realize that we do not need to have the zcumul in the 
             flexible dust opacity arrays; we need them only on the
             global frequency- and mu-array that is used in the 
             Monte-Carlo module. So I remove the %zcumul from the
             dust_kappaarray_link. 
             --> Done.

             dust_module.f90:
             Adding subroutine find_dust_zmatrix_interpol()

             montecarlo_module.f90:
             I finally finished remapping the Z matrix onto the local
             Monte Carlo frequency- and mu-array. I also calculated
             the cumulative arrays.

             montecarlo_module.f90:
             I also implement the anisotropic scattering for 
             non-polarized radiation (scattering_mode=3), based
             on the Z11 and Zcumul11 matrix elements. I added the
             anisoscat_randomdir() and anisoscat_phasefunc()
             subroutines for this.

             montecarlo_module.f90:
             Added mcscat_svec() array, which is complementary to
             the mcscat_dirs() array, and is used as the orientation
             vector for the polarization.

             camera_module.f90/camera_make_rect_image():
             Setting the mcscat_svec() vector appropriately.

             Note that we still have the possibility to set multiple
             mcscat_dirs directions. The idea behind this was that
             one would then only need a single Monte Carlo run for
             obtaining the scattering source function for a whole
             set of vantage points. I wonder how important this
             will be. I fear that it just makes the code unnecessarily
             complex, and I wonder if we will ever use it. For now
             this method is anyway not working yet. Oh well, let's
             keep it in for now, but I do not necessarily everywhere
             do the loop over idirs. 

             --> Compiles. So now, in principle, the anisotropic
                 scattering with tabulated scattering matrix should
                 work already. But of course the polarization mode
                 (even the simplest one: mode 4) still requires me
                 to allow for the Stokes vectors to be included in
                 the imaging. 

             But for now, let's commit it, just to have it safe.

             [---> radmc-3d_v0.35_01.09.12.zip]

             montecarlo_module.f90:
             I continued with building in the full polarization mode, in
             which the polarization state is taken into account during
             the Monte Carlo calculation. 

             --> Finished. Also compiles. So now, in principle,
                 the polarization, from the Monte Carlo perspective,
                 should now work fully. We still have to finish
                 the stuff in the camera_module.f90

             [---> radmc-3d_v0.35_01.09.12_b.zip]

02.09.2012   I think that "polarization_mode" is obsolete. Instead I
             should only check if we do an image in all four stokes
             components or not.
             ---> removing "polarization_mode"

             I had forgotten to include the position angle rotation
             of the S-vector. Now that is done.

             camera_module.f90:
             Continuuing the building-in of the polarization...

             [---> radmc-3d_v0.35_02.09.12_a.zip]

BUG FOUND    camera_module.f90/camera_serial_raytrace():
             In the part of camera_serial_raytrace() where the substepping
             of the doppler catching is done there was a bug:

               jc = eps1*jnu_curr + eps*jnu_curr + ln_jnu_curr


             must be:

               jc = eps1*jnu_prev + eps*jnu_curr + ln_jnu_curr

             Fortunately this was in the non-line part, so that 
             is not a serious problem. But it must be fixed anyway.
             ---> Fixed. [marked as BUGFIX 02.09.2012]
             
             sources_module.f90/sources_get_src_alp():
             Added the possibility to obtain srcq, srcu and srcv
             as well.

             sources_module.f90:
             We have to allow for the Q, U and V sources to be
             also stored on the vertices.

25.09.2012   source_module.f90/sources_compute_snualphanu_at_vertices:
             I now add the vertex arrays for the q, u and v sources. Done.
             source_module.f90/sources_find_srcalp_interpol:
             Now add this also to the interpolation. ---> IN PROGRESS

             Note that it has become a bit murky what the scattering
             modes are, because this is so far only described in the
             dust_module.f90. I now add a clear overview in the header of
             the montecarlo_module.f90 file, too.

             camera_module.f90/camera_serial_raytrace:
             Now I am going to do something drastic: All the instances of
             jnu_prev or jnu_curr, as well as snu_prev and snu_curr will
             now become arrays (1:4) for the IQUV. Done.

             In the doppler catching stuff we must, I think, just add
             the line emissivity to the I-component of the Stokes
             vector and to the opacity (which holds for all Stokes
             components). 

  &&&        userdef_module.f90:
             In the userdef_module.f90/userdef_srcalp() subroutine you
             now must declare src to be src(1:nrfreq,1:4) instead of 
             src(1:nrfreq).

             OK, I think that I have most of the implementation now
             done. The way it now works is:

               - If one of the dust opacities has polarized scattering
                 cross section data (non-zero Z-matrix elements other
                 than Z11), then the scattering_mode is put to 5 (unless
                 you have set scattering_mode_max to smaller).

               - But to obtain polarized images you must specifically
                 tell RADMC-3D so by adding the keyword 'stokes' on
                 the command-line.

             The code seems to compile without problems, so let's make
             a preliminary commit.

             [---> radmc-3d_v0.35_25.09.12_a.zip]

29.12.12     During the semester there was no time to work on the code,
             but now I finally find time again.

   +++       opac/dust_continuum/bohrenhuffman_scatmat/
             I added a new subdirectory to the opac/ directory: for
             making the dustscatmat_xxx.inp files with the Bohren
             & Huffman code (version of Bruce Draine). This seems
             to work. But if not a sufficient number of scattering
             angle points are used, the integral of Z_11 does not
             add properly up to kappa_scat. In particular for very
             small wavelengths compared to the grain size this is
             a problem because then the forward scattering is so
             extreme. I might want to check out if it is possible to
             use a non-regular grid in scattering angle in order to
             allow a better sampling near mu=1. In addition to that
             I think that it is necessary to do the Mie calculation
             at very high theta-resolution and then average down to
             a lower resolution in such a way as to preserve the
             integral over angle. For now, however, I just simply
             check if the error is too large. If it is, then I
             stop. If not, then I rescale. 

01.01.13     Continuing with the bohrenhuffman_scatmat/, and also
   &         making small improvements to the bohrenhuffman/
             directory (adding a comment header to the opacity
             file and adding comments to the param.inp file).

   +         I also now added the makeopac_distr, which allows to
             make the scattering matrices for a distribution of
             grain sizes. This can be important to smooth out the
             extreme wiggles in the phase function which are only
             realistic if one has a perfectly single grainsize,
             but is less realistic if you have a distribution of
             grain sizes. See the README file of that directory.

             [---> radmc-3d_v0.35_01.01.13_a.zip]

             Further small improvements.

             Bughunting RADMC-3D.

    !!??     montecarlo_module.f90:
             Why do I copy all the scattering matrix elements to
             an extra array with globally set nr of angles? Why don't
             I just use the actual read-in ones? I guess that that is
             possible with the thermal Monte Carlo, but for the 
             scattering Monte Carlo we could use a frequency somewhere
             in between the frequency grid. In that case you are forced
             to do interpolation. That is why I copied (and interpolated)
             the opacities in the first place, and that is why I do this
             with the scattering matrices as well. Another reason is
             that I anyway have to add further arrays such as the
             cumulative scattering matrix elements. 

             The risk is, of course, that this kind of interpolation (both
             in freq and by mapping from the read-in mu-grid to the global
             mu-grid) screws up the phase functions. I think that I must set
             the nr of mu-angles to the maximum of all the dust species.

             But what if the opacities use (for some reason) a 
             non-regular grid in scattering angle? If two opacities do
             so in a different way, then what should we take for the
             global mu-grid? 

    !        Decision: Let us, for now, only accept dust opacity files
             that have a regular gridding in angle. 
             I will also remove the read_scat_angular_grid(), since
             this only complicates things for the user. Instead, the
             user can (if he/she wishes) set scat_munr and scat_phinr
             to own numbers in the radmc3d.inp file. If nothing is
             specified, the scat_munr will be determined as the largest of
             the nr of angles in the dust opacity files, while scat_phinr is
             set at its default value of 180 (which should be enough since
             the phi-dependence of the scattering is weak: it is just a
             sine-curve with one period).

             OK, test... radmc3d mctherm. Hmm... crashes... For today I
             stop, however, because it is getting late.

             [---> radmc-3d_v0.35_01.01.13_c.zip]

             Note: If the opacity table has a wavelength domain smaller
             than the wavelength_micron.inp, then the outlying wavelengths
             will have kappa_a=0, kappa_s=0, g=0. I have not seen this
             cause trouble yet, but perhaps it would be good to check.

             OK the problem was just that in comparing the opacities
             it did not account for the case of kappa_s=0. Now that is
             fixed.

             Test: radmc3d mctherm works!! And in the time profiler I
             see that the polarization_randomorient_mc_scatter()
             subroutine is doing 12.8% of the work, so it appears
             to be doing something!

             [---> radmc-3d_v0.35_01.01.13_d.zip]

02.01.13     camera_module.f90/camera_write_image():
             I slightly modified the camera_write_image() subroutine.
             Now it will write all 4 Stokes components next to each
             other. That is more natural.

             OK, now test the image making: radmc3d image lambda 10 stokes

             Amazing... It seems to work!! The image produces indeed 
             interesting values of I, Q, U and V. Next we must check if
             these values are sensible.

             [---> radmc-3d_v0.35_02.01.13_a.zip]

  todo       I want to have one last look at the definitions of the
             Stokes components I, Q, U and V compared to the Mishchenko
             and Bohren & Huffman books. We use the IAU 1974 definition,
             but am I sure that the conversion between that and the 
             books is correct? I must make this sure, because otherwise
             this would cause huge confusion and the scattering matrix
             elements computed in the opac/ directory would be wrong.
             Still on the TODO list.
             ---> First results on check: I went through all the 
                  definitions again. I am now sure that the conversion
                  to Mishchenko is correct. I have to still get the
                  Bohren & Huffman book from my office tomorrow to 
                  check that conversion, but at least the Z-matrix
                  elements from the bhmie.f code produce consistent
                  results for I and Q for long wavelengths (i.e.
                  that for 90 degrees for Q=I the result is almost
                  zero, as it should be, and for Q=-I it is non-zero).
                  The rest I have to check tomorrow when I have the
                  B&H book.

             As for the testing: I have carefully gone through a number
             of subroutines, converted them into IDL and conducted some
             tests. These are the files test_anisoscat.pro, 
             test_henyeygreenstein.pro and test_rotatevec.pro. These
             all produce correct results. I made the following test
             for the full polarization mode: In a src_test/ version
             of the code I added the line 

               write(4,*) ray_cart_dirx*photpkg%n(1) + ray_cart_diry*photpkg%n(2) + ray_cart_dirz*photpkg%n(3)

             right after the call to polarization_randomorient_mc_scatter()
             (and of course opened and closed file unit 4), and plotted
             a histogram of this in IDL: 

               q=histogram(data,binsize=0.01)
               mu=2.d0*dindgen(200)/199.-1.d0
               ang=acos(mu)/!dpi*180.
               plot,ang,q

             I then overplotted the phase function:

               o=readopac(spec='pyrmg70',/scatmat)
               inu=56      ; The wavelength for which the image is made
               oplot,o.angle,o.pmat[0,*,inu]

             These give a very good match! Question: do we even expect
             to have such a good match? Answer: yes, we do, because
             for randomly oriented particles the phi-integrated 
             scattering phase function (i.e. 2x the probability 
             of scattering with theta=acos(mu), irrespective if phi)
             is independent of the input polarization state. So we
             have shown that at least the mu-part of the scattering
             phase function is correct in RADMC-3D in the full
             polarization mode. Since in the polarization module
             we first pick the phi-direction, and then the mu-direction,
             it might (!) be also a test that the phi-picking is not
             flawed. But I am not sure. More testing necessary. But
             for now it seems to work excellently!

03.01.13     Further testing... I tested if indeed the Q/I is near -1
             for 90 degrees scattering. This indeed appears to be
             the case, which is good. But I find that sometimes 
             it is 0 (and also U and V are 0). I checked this and
             found that that is the case when E is around 1E-250,
             i.e. nearly zero. How can this be? 

   BUGFIX    Moreover, I suspect that I do not decrease photpkg%E by
             xptauabs after each step in the scattering Monte Carlo (I have
             not forgotten this in the final segment, but I did forget this
             in the normal segments).

             I checked the conventions now against the Bohren & Huffman as
             well as Wendisch & Yang books. Both books have, at least from
             the math perspective, the same conventions as Mishchenko, but
             they define "horizontal" and "right-handed" differently.
             I put the corresponding text in the manual.

   BUG       Somehow the dust temperature is 0 everywhere in my 
             test model. Reason: when reading the dustscatmat opacity
             file I did not remap the kappa_a, kappa_s and gfactor
             onto the global frequency grid. This is important if
             the global frequency grid is larger than the frequency
             grid of the dust opacity file. So what happened was that
             the kappa_a was 0, leading to NAN, which lead to zero
             dust temperature. Now I added the remapping, but now
             the kappa_s and zmatrix are not mutually consistent. I
             thus also need to do the extrapolations for the zmatrix.
             That has to be implemented in the subroutine
   TODO      find_dust_zmatrix_interpol(). 

 minibugfix  mathroutines_module.f90/remap_function()
             In the double-logarithmic extrapolation formula for the
             eup=2 end was a mistake. Is now fixed. This has no consequences
             for the code, because only elow was ever set to 2. But in 
             case I ever use this subroutine elsewhere, it is better that
             it is now fixed.
             
 Bug fixed   dust_module.f90/find_dust_zmatrix_interpol()
             I now implemented the extrapolation of the zmatrix elements
             beyond the frequency scope of the opacity files. I do
             this in exactly the same way as for the kappa_scat, except
             that I do not extrapolate Z(1...6) independently, but
             instead scale Z(2...6) with the same factor as computed
             for Z(1). This way the relative behavior of Z(1...6) 
             among each other remains the same.
             
             ---> Now I get the dust temperatures back! So that seems
                  to work again. Great!

             [---> radmc-3d_v0.35_03.01.13.zip]

04.01.13     montecarlo_module.f90:
  BUGFIX     I am checking the scattering source stuff for the polarized
             scattering. I think that there is an error in 
             there still. I think that the division by 4*pi is
             wrong, since Z is equivalent to kappa_scat/4pi, so the
             division by 4*pi is already done. This is now fixed.

             I also went again through the subroutine 
             polarization_randomorient_scatsource(), just to check that
             everything is done ok. I think that it is correct. I checked
             all the angle conventions and the overall procedure (first
             convert to scattering plane, then convert to the observer
             S-vector) and it seems ok. In the case when n lies in the
             direction of nobs I now replaced the original procedure
             (wiggling n) to a call to polarization_make_s_vector(),
             which produces a random consistent S-vector in this case.

             Question: Does the iseed for the scattering monte carlo
             simulation for movie mode get reset each time? That would
             be useful if you want to make a movie with the same
             model at different vantage points without seeing in 
             every frame a slightly different scattering noise.
             Answer: Yes, it is already built in and it is called
             iseed_start. I just need to make it possible to set
             iseed_start from the radmc3d.inp, which is currently
             not possible.

             main.f90:
        +    I set iseed_start = iseed, which allows you to set the
             iseed_start by setting iseed in the radmc3d.inp file.

   BUFIX     I realize that since the integration scheme is not
             always linear (there is a theomax involved to prevent
             overshoots), the condition that Q^2+U^2+V^2<=I^2 is
             no longer guaranteed to be obeyed. So I now want to
             to implement the theomax a little bit differently:
             First implement it is I, and if it sets in, I also
             scale the Q, U and V with the same factor. Then I
             check if Q, U and V overshoot. 

   BUGFIX    I realize that abssina=sqrt(1.d0-cosa**2) is less
             accurate for small angles than the cross product
             formula. Is now fixed. I now only take the cross
             product formula.

             OK, I think that now a first version of the code 
             with polarization is ready for real testing. 

             [---> radmc-3d_v0.35_04.01.13.zip]

06.01.13     montecarlo_module.f90:
  bugfix:    I forgot to deallocate the zmatrix, zcumul, mui and
             thetai grids. Now done.

     &       viewimage.pro and readradmc3d.pro:
             I improved the viewimage.pro and readradmc3d.pro IDL
             codes. Nothing major, but some nice new things, such that you
             can now set the nphot_scat from within viewimage, and you can
             fix the initial iseed for the scattered light images, so that
             you can study a "streaky pattern" for low nphot_scat from
             different angles.

             I have continued the testing of the images with viewimage.pro
             and was initially a bit confused by very bright and very dim
             "streaks" in the images. However, I realize that that is due
             to the weighted photons: the weak ones are from the thermal
             dust emission while the bright ones were from direct starlight.

             I have tested the "streaky patterns" for ultra-low nphot:
             For instance, nphot=1 (one streak), nphot=2 (two streaks)
             and you can then really see where the photon package had
             its scattering event: where the streak bends into another
             direction. This also made it possible to test if indeed
             the brightness for the case when you look into the beam
             of radiation is substantially brighter due to the forward
             scattering than when you look from the side. It all seems
             at first sight to be reasonable.

             [---> radmc-3d_v0.35_06.01.13.zip]

19.02.13     montecarlo_module.f90:
  BUGFIX     Attila Juhasz and Daniel Harsono found a bug in the MRW 
             for spherical coordinates. Attila Juhasz found where it
             was going wrong. It was when doing the disk with theta
             including both upper and lower part (crossing equator).
             He fixed it (see "BUG FOUND AND FIXED BY ATTILA JUHASZ").

08.03.13     sources_module.f90:
  BUG!       Rolf Kuiper set up a model in spherical coordinates and
             could not get the 2nd order integration to work. Indeed
             this appears to be a bug (or presumably multiple bugs)...

  Fix        OK, I found the bug that caused empty images: in the 
             sources_compute_snualphanu_at_vertices() there was:
                 amrray_ix_curr = ixx+ix-2
                 amrray_iy_curr = iyy+iy-2
                 amrray_iz_curr = izz+iz-2
             But for spherical coordinates with axial symmetry this
             made amrray_iz_curr=0. Now I added "if(amr_zdim.eq.1) then"
             statements. That appears to fix it. 

             If using the istar_sphere=1 (finite size star) then 
             I get "ERROR in srcalp interpol: index le 0". This
             must be fixed still (see below).

  &&&&&&     In the mean time: sources_module.f90/sources_get_src_alp():
             I notice that in the sources_get_src_alp() subroutine I
             have the if(ray_index.gt.0) statements scattered throughout,
             but it can be done right after the "...Reset the alp and src"
             statement. 
             ----> I have now implemented this, and removed the further
                   if(ray_index.ge.1) statements inward of that.

             This has the consequence for the userdef_srcalp() that you
             do not have to do an if(ray_index.gt.0) statement in the
             userdef_srcalp() anymore. This is safer. Otherwise the user
             might accidently add a source term when the ray is in fact
             outside of the grid. NOTE: This can only happen in spherical
             coordinates where a ray can enter, exit and re-enter the grid.

             In principle this change should not affect anything in the 
             way the code works. But it is safer. I should, however, keep
             an eye out for possible bugs introduced with this action...

08.03.13     amrray_module.f90/amrray_find_next_location_spher():
  BUGFIX     The way the star spheres are built in right now (if the
             sphere is outside the grid) is that the crossing with
             the sphere is checked in two separate points: (1) if
             the ray never crosses the grid and (2) if the ray
             crosses the grid. This is silly because it is double
             work. Also I think that if a star sphere is hit, then
             the amrray_icross must be set to 0. I fixed both things
             now. 

             ----> Now the model of Rolf Kuiper is working! So the bug
                   appears to be fixed. Let's hope I didn't accidently 
                   destroyed something else ;-).


10.03.13     I added some more tips to the RADMC-3D output if it finds
             excessive subpixeling. 

  ++         I added the "sloppy" command-line option to prevent excessive
             subpixeling, but without guarantee that all cells are really
             resolved. 

18.03.13     montecarlo_module.f90/camera_serial_raytrace()
  BUG        I realize that if we use mirror symmetry (like when using
             2-D axial symmetry) we cannot use non-isotropic scattering.
  Fixed      Perhaps at some point I must improve this. But for now I
             will simply stop the code with an error message. I do the
             same for spherical coordinates with less than 3 dimensions.

24.03.13     I must explain in the manual the problem for the scattered light
             source function for optically thick cells. The problem is the
             following: if a cell is optically thick to stellar light, then
             all stellar light will be absorbed in the first exp(-1) optical
             depth of the cell, yet the "energy" is smeared out over the
             entire cell. When you then make an image, the resulting image
             from these cells is orders of magnitude too weak. This gives
             the strange double-ring structure seen from the inner edge of 
             a protoplanetary disk model for which the inner edge is not
             sufficiently resolved. I think that the problem is less severe
             for the thermal absorption-reemission because there the photon
             packages are not destroyed, but continue to bounce. 
  todo       Not yet done...

28.03.13     montecarlo_module.f90:
  ??         It seems that the iphotcurr variable is an orphan. I have
             to remove that and use mc_iphotcurr instead. Since I do
             not use this variable anyway at the moment, this is not
             a problem. But if I ever want to re-use this (which is
             important for checking the photon statistics in cells)
  fixed      then it needs to be fixed. I now fixed it.


06.04.13     mathroutines_module.f90
  !          I realize a tiny bug in the use of the ran2() random
             number generator: It still has EPS=1.2e-7, meaning that
             ran2 will never generate a number larger than 0.99999988.
             That is ok for most purposes, but just keep this in mind.
             For now I won't change/fix this because it would change the
             automatic test cases.

18.04.13     idl/radmc3dfits.pro
  bugfix     Small bugfix: in radmcimage_to_fits() change filename to
             fitsname. Thanks Eric Jensen for the bugreport and fix.


25.04.13     Makefile:
  bugfix     Dependencies of sources_module were wrong: Must be DMODULES
             instead of GMODULES.
  bugfix     Dependencies of stars_module were wrong: We added HIMODULES
             between HMODULES and IMODULES and let stars_module.f90
             depend on HIMODULES.

03.05.13     montecarlo_module.f90/do_absorption_event():
             The if(calctemp.and.(params%ifast.ne.0)) then statement can
             be shifted upward before the pick_randomfreq_db() 
             inside the if(calctemp) clausel.


*** DO CHECK: IS MIRROR EQUATOR IMPLEMENTED CORRECTLY WITH ANISOTROPIC SCATTERING?

*** REMOVE RESTART STUFF ***

23.05.13     dust_module.f90:
 bugfix      Bugreport and fix from Jack Dobinson:
             Where w check that the lambda array is monotonically 
             increasing/decreasing: elseif statement .gt. must be .lt.
             Fixed.

28.06.13     

*** CHECK: It seems that when I call read_linedata() I also cleanup any
    molecular density distribution arrays. That should of course not
    happen. ***

28.06.13    Let's end version 0.35 here, so that we can improve the management
            of the line arrays (allocation and cleanup) such that it will be
            possible for the userdef_module to create its own line model,
            and not run into the troubles that Camilo Penaloza ran into
            where the lines_cleanup() cleaned up the model he just produced.

==============================================================================
                              VERSION 0.36

Here we will improve the line array data management.
==============================================================================

28.06.13    lines_module.f90:
            Right now the lines_cleanup() subroutine cleans up all line
            related arrays. That is problematic for some methods of 
            user-defined model development. In the dust modules it was
            done differently:
              - dust_cleanup() only cleans up the dust lab data arrays
              - rtglobal_cleanup() cleans up the dust distrubiotn model
            So let us now do this likewise for the lines! So we will
            reduce the lines_cleanup() to only cleaning up the actual
            lab-related data, and leave the model cleanup for the
            rtglobal_cleanup(). We will create a subroutine called
            separate lines_model_cleanup() which we will call from the
            rtglobal_cleanup().

            We moved a lot of arrays from the lines_module.f90 to the
            rtglobal_module.f90. That was necessary, because otherwise
            the rtglobal_module does not have access to those arrays,
            and can thus not delete them. Note that lines_module.f90
            uses rtglobal_module.f90.

            ----> Make is succesful! 

01.09.13    Repeated the run_lines_nlte_lvg_1d_1 test with this new 
            version. Seems to do reasonable things. With zero velo
            gradient you get indeed LTE populations, while with a
            velo gradient you get subthermal populations. 

   +        idl/readradmc.pro/read_levelpop()
            I now added the possiblity to immediately calculate also
            the excitation temperatures for all the lines if you 
            read the level populations with read_levelpop(). But this
            works only if the full level diagram is used. You can
            activate this by calling read_levelpop in the following
            way:

              a=read_levelpop('co',/ext)
              print,a.ext[*,5]

           This will read the level populations for CO and print the 
           excitation temperatures for all the line at cell nr 5.

07.09.13   lines_module.f90:
   &       I want to add a few possibilities to fine-tune the LVG stuff.
           First, since the LVG mode also encompasses the escape probability
           method, I want to make it possible to use *only* the escape
           probability method, allowing a one-cell setup for testing 
           purposes. Done. See examples/run_lines_nlte_radextest_*/ 
           tests which are compared to RADEX of Floris van der Tak.

           [--> radmc-3d_v0.36_07.09.13_a.zip]

07.09.13   lines_module.f90:
   +       Added the following trick: If the LVG does not converge, the
           subroutine will call itself one more time (recursively) but
           with debugging info switched on, so that you can see how
           the populations evolve during the iteration. This gives 
           better diagnostics.

07.09.13   lines_module.f90 and main.f90:
   &       I now increased the default max number of iterations to
           lines_nonlte_maxiter      = 100

           Note that this MAY make small changes in the results of
           certain calculations for the earlier versions of the code
           (version 0.32 and earlier) because those versions gave a
           message but did not abort if convergence was not reached.
           However, if no such error messages ("LVG FAILURE!...")
           were printed, then the results should be the same.

           [--> radmc-3d_v0.36_07.09.13.zip]

08.09.13   lines_module.f90 and main.f90 and rtglobal_module.f90
           I realize that perhaps some of the problems that some
           people may have could be due to masering. Currently the
           code does not yet check for that. 

   &&&&    I now prevent negative tau in the LVG iteration, and I
           put on a warning flag if negative tau is detected

   &&&&    I now also prevent negative opacity in the imaging and
           spectra and give warning if detected.

12.09.13   lines_module.f90, mathroutines_module.f90
           Sometimes the code crashes with a singular matrix 
           problem. The problem is that it will then not 
           produce any diagnostics. I now implement that it
           will not crash but instead put the "dbg" flag up,
   ++      so that it will redo the thing with the verbose
           output and then stop.

03.11.13   Since I want to start building in the gas Monte Carlo
           I want to stop version 0.36 here.


==============================================================================
                           VERSION 0.37

Here I want to include the gas Monte Carlo. 
==============================================================================

21.10.13/  Brainstorming about how to include user-defined
03.11.13   temperature-DEPENDENT "dust"-opacities into the Bjorkman & Wood
           algorithm. The idea is to be able to use the dust Monte Carlo
           temperature calculation algorithm to calculate GAS temperatures
           with GAS opacities. If you use sufficiently many frequency
           sampling points, it will de-facto act as a frequency opacity
           sampling method. RADMC-3D will then think it is dealing with a
           temperature and density dependent dust opacity, whereas it in
           fact unknowingly deals with gas LTE opacities. The result will be
           the LTE gas temperature.

            - In B&W the opacity table is not allowed to change as a
              function of temperature.

            - So if the opacity table IS dependent on temperature, then we
              must do an iteration loop over the B&W algorithm, where we
              store the previous result of the dust temperature T_prev, and
              compute the opacity table at each moment during the MC
              algorithm using the T_prev.

            - Then iterate until convergence. But how do we know if we
              converged? The problem is that the Monte Carlo noise will make
              it impossible to put stringent convergence conditions on the
              problem.

           So we must build in the following things into RADMC-3D:

            1) Possibility for an iteration loop around the B&W Monte Carlo
               procedure

            2) User-defined dust opacity table subroutine that we feed:
                - frequency (or frequency array)
                - density
                - T_prev 

            3) Let us do this for an additional component: the gas. The
               dust species remain treated in the constant opacity way.

            4) So we will need to have a good estimate of the starting
               temperature. Let's just read this from some file.

           Problems on the horizon:

            - We will not be able to use the look-up table for the
              emissivity of dust particles, because the opacity table will
              be different from location to location. Will replace
              make_emiss_dbase().

            - Recalculating the gas opacity every time can be too
              time-consuming. We can also precalculate the opacity
              tables. For 2-D axisymmetric models this should still be
              doable.

           IF we use the precalculation of the opacity tables, then we do
           not need to store T_prev anymore. Only perhaps to check
           convergence!

           So we have two opacity subroutines (=Nick Malygin's routines).

           1) Precalculate the opacity tables for EACH cell. This gives a
              table kappa_abs_local(inu,icell)

           2) If we have during the MC inu and icell, we can immediately
              copy the opacity from the array.


07.02.14    montecarlo_module.f90/walk_cells_scat()
 BUGFIX     The mcmono with scattering has a problem that is now fixed.
            It used to be:
             
              ! Add photons to scattering source
              ............
              if(alpha_s_tot.gt.0.d0) then
      
            and it should be:

              ! Add photons to scattering source
              ............
              if((alpha_s_tot.gt.0.d0).and.(allocated(mcscat_scatsrc_iquv))) then

            Note that I *did* fix this at one point in the code, but
            I forgot to fix it also in another point. This is now fixed.
            
            Thanks to Gwendoline Stephan for reporting the problem.

14.04.14    I have not made much headway with the gas-Monte-Carlo. But
            right now a new priority appears: merging Adriana Pohl's
            OpenMP-acceleration stuff back into the present version,
            and then having Thomas Peters include the possibility of
            using superlarge integers for indexing superlarge models.
            So for now let us wrap this version up. 

==============================================================================
                           VERSION 0.38
==============================================================================

14.04.14    So let us now first work on the implementation of the 
            OpenMP acceleration of the thermal Monte Carlo by Adriana
            Pohl.

            --> Done. But not yet tested. 

03.05.14    Interesting problem reported by Ke Zhang: If you use a 
            partial molecular level list for computing LTE lines
            (using an externally pre-computed partition function
            table read in via the file partitionfunction_<mol>.inp),
            then you must make sure that the ground state is 
            included, otherwise the energy normalization in the
            lines_compute_ltepop() subroutine goes wrong. 

   +        I now write out a warning whenever the external 
            partition function is read. This is safer. I also now
            included some explanation in the manual. 

03.05.14    Bug report by Seokho Lee:
  BUG       I think my BUGFIX 14.02.2012 for computing the mean
            intensity (see above) was wrong. Seokho Lee
            correctly pointed out that ds is still the length of
            the path to the end of the cell instead of to the
            next scattering event. Since (I think) the location
            where BUGFIX 14.02.2012 was done will only be reached
            if the local scattering opacity is >0 we better switch
            back to the original formula...
  FIXED     I fixed it now according to Seokho Lee's suggestion.
            Just for security I added some tests, which can be
            removed later.
            I marked the bugfix with BUGFIX 03.05.2014.

05.05.14    Bug report by Soren Frimann: The aperture mode does
            not work properly. It produces wildly off results. 
!!!BUG!!!   I think it might be because I did not set the 
            camera_image_halfsize_x, camera_image_halfsize_y
            properly. 
  FIXED     I now improved this. I added in particular:

              !
              ! Set the size of the image
              !
              camera_image_halfsize_x = r_colarea
              camera_image_halfsize_y = r_colarea

            right after the line 

              r_colarea = r_colarea * AU * camera_observer_distance_pc

            and before the

              !
              ! Set the pixel sizes
              !
              pdx = 2*r_colarea / (1.d0*camera_image_nx)
              pdy = 2*r_colarea / (1.d0*camera_image_ny)

            Now I performed the test of Soren Frimann again and
            I get better resuls: the circular aperture results
            are now much more similar to the square aperture
            results.

            Thanks to Soren Frimann for his careful testing of this
            aperture mode and finding this bug.

            [--> radmc-3d_v0.38_05.05.14.zip]

05.05.14    Another interesting thing found by Soren Frimann is that for some
            models (presumably those where the optical depths between
            adjacent cells can differ strongly, i.e. an optically very thin
            cell next to an optically very thick cell) the fluxes obtained
            by using second order integration might differ strongly from
            those obtained using first order integration. I think that the
            explanation is that for the dust radiative transfer the first
            order integration of the images is then more reliable than the
            second order, because the first order integration assumes
            constant temperature per cell, which is also the assumption of
            the Monte Carlo method. The second order integration, on the
            other hand, does some smearing out of the sources, which could
            lead to emissivity being diffused into optically thin
            neighboring cells, which would then become far brighter than
            they should be based on energy conservation considerations.

11.05.14    camera_module.f90:
  ++        Attila Juhasz added C-style unformatted output images.

June 2014   OpenMP-Parallellization of thermal Monte Carlo:
            Adriana Pohl created a version of RADMC-3D in which the 
            thermal Monte Carlo is parallellized with OpenMP. That was
            non-trivial because of the possibility that two parallel
            photon packages enter the same cell at the same time. 
            She solved this problem by locking the cell when a photon
            package enters. 

            I now implemented her parallellization stuff into my current
            version of the code. It seems to work, but since I had to 
            effectively merge two code versions I cannot guarantee with
            100% certainty that it works perfectly. As usual, the community
            will have to help me testing.


21.06.14    run_lines_nlte_optthin_0d_1/ 
  Bug       Something is wrong with this setup with the new version of the
            code. Bugreport from Liliana Lopez. 
            I think this is because I added "autosubset" (already a while
            ago). I will chance the README file of that directory.

14.08.14    OpenMP: Farzin Sereshti notifies that in case of two photon
  bug?      packages entering the same cell, the second photon must wait,
            not skip the cell. Maybe a (small) bug? TODO.

******************************************************************************
22.10.14    
POTENTIAL BUG?
            Han Zhang reported that mirror symmetry appears to be incompatible
            with polarization. That is a potentially dangerous bug! 
******************************************************************************

24.02.15    I now insert an error message if mirror symmetry is used
            with polatization.

24.02.15    montecarlo_module.f90
bugfix      Marked by BUGFIX by Seokho Lee 24.02.2015:
            In pick_randomfreq_db() the line
                 call hunt(enercum,dust_nr_species,rn,ispec)
            must be replaced by 
                 call hunt(enercum,dust_nr_species+1,rn,ispec)
            Interestingly this goes mostly (accidently) right, because
            if rn is larger than the largest value, hunt returns 
            dust_nr_species. But in exceptional cases it still can 
            go wrong. 

==============================================================================
                           VERSION 0.39
==============================================================================

04.03.15    montecarlo_module.f90
  bug?      It seems that the external radiation field is not working
            together with OpenMP... (Thanks to Andrea Isella for reporting this)

04.03.15    amrray_module.f90
  bug..     The MC sometimes stops with "out of cell" error. 
            With external radiation field the occurrance of this problem
            is much higher, which makes sense, because it happens much more
            often that a photon enters the theta-grid-edge from outside.
            (Thanks to Andrea Isella for reporting this).

  ..fixed   The problem with the "out of cell" error is that in the solving
            of the quadratic equations for the section of the ray with the
            cone of the theta=constant coordinate there can be cases of
            near-cancellations. I have to catch this and replace the
            (pb - sdet) with the taylor series expansion. I had to do this
            at 6 points in the subroutine amrray_find_next_location_spher().
            These are marked with "BUGFIX: 06.03.2015". 

05.03.15    lines_module.f90
 !!BUG!!    In sperical coordinates the second order integration of line 
            images goes wrong. (Thanks to Sebatian Perez for reporting this)

  ..fixed   sources_module.f90/sources_compute_snualphanu_at_vertices():
            I forgot to convert the coordinates ray_cart_x,y,z from cartesian 
            to spherical. This bugfix is marked with BUGFIX: 06.03.2015-2.

            BUT: This goes wrong for 2-D spherical coordinates (i.e. if we
            only use r and theta, and have only 1 cell in phi-direction).
            We now include a stop in the code if someone wants to use
            lines with second order in 2-D spherical coordinates.

06.03.15    lines_module.f90
  bugfix    In checking if ntempmax.gt.lines_collisions_ntempmax or
            ncolltransmax.gt.lines_collisions_ntransmax I forgot to 
            do this checking only if(col_npartners.gt.0). I now added
            that. Not a serious problem, just that it could simply stop
            the code.

06.03.15    montecarlo_module.f90 and camera_module.f90:
            Insert a check to make sure that small-angle scattering in 
            spherical coordinates is only used with full 3-D spherical
            coordinates.

10.03.15    amrray_module.f90:
 still bug  The out of cell error still happens, though much less 
            frequently, and mostly if a strong external radiation 
            field is applied. I think it is because the switch
            from full formula to Taylor series happens at a threshold
            of 1d-4. This means that you have a precision of 1d-12
            left. Since the "tol" parameter is set to 1d-12, this is
            just on the border, with no margin. Since this error is
 CHANGE!    anyway just for safety checking, I will now loosen the
            tolerance ("tol") a bit: setting tol=1d-10 instead of
            1d-12. 
            
            I marked this with CHANGE 10.03.2015.

10.03.15    montecarlo_module.f90
 MAJOR      Farzin Sereshti's OpenMP solution is now implemented and seems 
 MODIFI-    to work! It speeds up the code enormously, and seems to overcome
 CATION     the problems with the scaling to multiple processors.

            In addition to this, Farzin's method is now also implemented
            for the scattering images.

            Thanks, Farzin, for this new OpenMP-parallellization method!

17.03.15
            ----> radmc-3d_v0.39_17.03.15.zip
            ----> Distributed to mailing list

18.03.15    montecarlo_module.f90
 bugreport  by Attila Juhasz:
            When the photon counter reached the 160million
            it stalls. It stays there and keeps throwing 
            messages that its trying to do a backup
            but its not yet implemented.

   -->      I comment out the entire dump thing, because it is not
            used anyway and may not even work (it was something I
            implemented a very long time ago, and almost immediately
            disabled). 

24.03.15    --------------------------------------------------------
                  TODAY THE RADMC-3D FORUM HAS BEEN ACTIVATED
            --------------------------------------------------------

24.03.15    Til Birnstiel askes if RADMC-3D has a photon statistics
            counter. It does, but it is not activated nor "wired".
            It is the array mc_iphotcount(:).

  &&        montecarlo_module.f90
            I change mc_iphotcount(:) from integer to double precision,
            so that we can use the write_scalarfield() subroutine
            to write it out in standard format. 

  ++        montecarlo_module.f90
            Implemented write_photon_statistics_to_file() which uses
            write_scalarfield() to write out the statistics. 

            main.f90
  ++        Adding possibility to set debug_write_stats to 1 in the
            radmc3d.inp file. 

24.03.15    montecarlo_module.f90
 bug??      Han Zhang reports: As it is optically thick in some region 
            in my disk (spherical coordinate), i switch on  Modified 
            Random Walk mode by adding Modified Random Walk=1 in the 
            radmc.inp. But it stops when i run radmc3d mctherm 
            (STOP 3902). Why? ---> Maybe a bug? ---> Must look into
            this, but not now...
            Han Zhang says that it depends on the opacity chosen.
            Maybe due to a "zero" in the opacity table?

26.03.15    montecarlo_module.f90
  ++        I am trying to implement (activate) the viscous heating
            capability for RADMC-3D: This is simply an internal 
            heat source inside each cell that directly pumps energy
            into the dust grains. It does not have to be "viscous
            heating"; it can also be a chemical heat source or
            cosmic ray heating or whatever. 

            It is mostly already there (from the old RADMC), so I 
            mostly had to just "activate" the code fragments and
            remove safety stops.

   &&       montecarlo_module.f90, main.f90, rtglobal_module.f90, stars_module.f90
            I change all qvisc --> heatsource because that describes
            better what it really is. It can be any kind of heat source,
            viscous heating being just one kind.

            stars_module.f90:
   ++       Added read_internal_heatsource() subroutine.

            main.f90:
   ++       Added a call to read_internal_heatsource(). 


            IN PROGRESS...

30.03.15    montecarlo_module.f90/find_next_location_spher_lite()
  bug?      In amrray_module.f90/find_next_location_spher() the theta1
            is always the theta closest to the pole, while theta2 is
            always the theta closest to the equator. However, in 
            montecarlo_module.f90/find_next_location_spher_lite()
            is that still the case?? CHECK...

31.03.15    montecarlo_module.f90/find_next_location_spher_lite()
 BUGFIX     Yes, it was a bug. I now swapped sct12(*,1) and sct12(*,2)
            if we are in the lower quadrant. Now it works again
            for models that include both the upper and the lower
            quadrant (i.e. theta crossing the equatorial plane).
            It is marked as BUGFIX 31.03.15.

31.03.15    montecarlo_module.f90/modified_random_walk()
improvement The MRW can sometimes be a bit unstable. I suspect that
            it is because I use the exact distance to the nearest
            cell wall. I tried to make it a tiny bit smaller by
            adding a line distclose = distclose * 0.99 to the code.
            After some testing it seems to indeed be more stable.
            I marked it with IMPROVEMENT 31.03.15.

09.04.15    montecarlo_module.f90/modified_random_walk()
            Til found that it still sometimes leads to an out of
            cell error. It seems, however, to be only 1E-15 out
bugfix      of cell in theta. I add a margin, so that the error
            is not so quickly triggered. It is just a check, and
            it should work also if there is a 1E-15 out of cell.

            Marked with BUGFIX 09.04.2015

13.04.15
BUG         amrray_module.f90/amrray_find_next_location_spher()
            Very subtle problem found. If a ray starts from a cell wall
            (i.e. within a tiny distance "tol" from the cell wall), normally
            this can only happen if the ray is passing from one cell to the
            next, because the chance that it *starts* at the cell wall (i.e.
            that an event happened at the cell wall) is very small. This
            means that if a ray starts from a cell wall it just came from
            another cell (or from outside) and thus *always* points
            inward. The algorithm is such that it does not, in that case,
            accidently "find" the crossing with this same cell wall.

            HOWEVER, at ultra high optical depths (in particular when
            using also the modified random walk) there is a good 
            chance that an event accidently happens ultra close to
            a cell wall. The ray direction then points *toward* the
            cell wall (i.e. outward). However, as mentioned above,
            the algorithm is not geared up to find this crossing
            then. It might accidently find it, but it might also
            accidently skip it. In that case it would find another
            crossing, which would make things go mad. 

**BUGFIX**
(dangerous one!)
            amrray_module.f90/amrray_find_next_location_spher()
            --> DID I FIX THIS? Not sure...

02.11.15    viewimage.pro
   bug      If the wavelength_micron.inp has a largest wavelength that
            has too many non-zero digits behind the comma, then the
            viewimage.pro can round off the wavelength wrongly and 
            produce a wavelength just outside of the range. This would
            then crash the viewimage.pro... 
            
   fix      This is now fixed. I simply check if the lambda is out of
            range (but just a tiny bit). If so, it will fix it.


22.02.16    rtglobal_module.f90
Bugfix 22.02.2016
            If the write_vectorfield() writes numbers in ascii output
            format that are smaller in absolute value than 1d-99, then
            fortran produces a strange output: instead of 1.d-100 
            it becomes 1.-100. So catch this.

22.02.16    readradmc.pro/read_levelpop()
BUG         I notice that in the calculation of the excitation 
            temperature I have the indices wrong (though for the CO
            ladder it is accidently right!). 

                iup=lindata[1,iline-1]
                ilo=lindata[0,iline-1]

            This should instead read

                iup=lindata[1,iline-1]
                ilo=lindata[2,iline-1]

            Again: for linear molecules from the lambda database
            this happens to be the same, which explains why in my tests 
            it worked...

22.03.16    rtglobal_module.f90/bplanck() and bplanckdt()
bugfix      Bugfix by Jon Ramsey
            Added some exception handling to prevent overflows. Does
            not affect results, but can be useful when checking for
            floating point exceptions.

22.03.16    montecarlo_module.f90/walk_full_path_bjorkmanwood()
BUGFIX      Bugfix by Jon Ramsey
            When using internal heat source and weighted photon
            packages, the call to do_absorption_event() uses
            the "energy" that was not yet set properly. Fixed.

            Search for: "Bugfix 22.03.2016 by Jon Ramsey"

22.03.16    montecarlo_module.f90/modified_random_walk()
BUGFIX      Bugfix by Jon Ramsey
            In `modified_random_walk`, at the end of the MRW step, when we
            backtrack a little bit to ensure the photon package stays in the
            current cell (lines 9211-9216 of montecarlo_module.f90), Jon was
            occasionally finding that `ds_margin*dir(:)` was below machine
            precision relative to `pos(:)` and the photon package was not
            moving. Thus, Jon added one line in between lines 9211 & 9216
            another fix.

            Search for: "Bugfix: Jon Ramsey, 14.02.2016"

22.03.2016  montecarlo_module.f90/do_monte_carlo_bjorkmanwood()
            montecarlo_module.f90/do_monte_carlo_scattering()
            main.f90
BUGFIX      Bugfix by Jon Ramsey
            OpenMP needs to know the nr of threads BEFORE the 
            private arrays are allocated. Now the call to the
            OMP_set_num_threads(setthreads) routine is done in
            main.f90 right after the setthreads value has been
            set definitively.

            Search for: "Bugfix by Jon Ramsey 22.03.2016"

20.06.2016  I now went through all the selftest models, which now
            (with the fix in the Planck function bplanck()) yield
            slightly (at the level of 1E-14 relative) different 
            answers. The self tests therefore formally failed, but
            since the answers are only different at the double
            precision level (1E-14). So they are all ok. The 
            self-tests that I run are therefore now updated. 

----> Let's release version 0.39. I will ask the community to 
      do their checks.

==============================================================================
                           VERSION 0.40
==============================================================================

20.06.2016  New version in which many example models now have
            a python version in addition to the idl setup routine.

26.07.2016  lines_module.f90/lines_compute_velgradient():
BUGFIX      When computing the velocity gradient on an AMR grid,
            the distance between the cell centers between a small
            cell and a larger neighboring cell was increased by
            a multiple of 2. I think that this is incorrect, because
            already the ds between the centers of the(different-size) 
            cells was computed. So I removed that. This only affects
            models with AMR.

            Marked as BUGFIX 2016.07.26

26.07.2016  lines_module.f90/lines_compute_velgradient():
ADDED       I added the possibility to compute (instead of the 
            average) the maximum velocity gradient. Note, however,
            that like the average the velocity gradient is still
            directionally split! But by computing the maximum
            instead of the average it will be possible to implement
            a warning if cell-by-cell line shifts are too large to
            do RT without the doppler catching method.

ADDED       lines_module.f90/lines_compute_maxrellineshift()
            This subroutine computes the maximum ratio of cell-to-cell
            doppler shift versus local line width. This is useful
            to check if doppler catching is required.

29.07.2016  [---> radmc-3d_v0.40_29.07.16.zip]

29.07.2016  Here's a little todo list for the coming weeks (hopefully
            finding time for that :-/)

             - Fix problem with line transfer in 1-D model of
               a collapsing cloud (where the projected velocity
               v_proj=0 is overestimated if the Delta R/R is too
               large).

             - Fix some of the strange features seen in line images
               using 2nd order integration

             - Implement the PAH module

             - Fix the problem with the Modified Random Walk when
               an extreme chance-incident happens near the cell
               corners: just give the photon a random tiny offset.
               That should do the trick.


15.09.2016  camera_module.f90:
finetuning: I noticed during some testing with a supersimple annulus model
            that for such extreme cases the 2x2 pixel + sub-pixeling
            method for making a spectrum underresolves the images in spite
            of the subpixeling. The reason is apparently that some rays
            completely miss everything. I think that this might be 
            dangerous under some circumstances. So I decided to get rid
            of the 2x2 pixel idea for spectra. Instead, by default always
            the full 100x100 images are rendered (plus subpixeling of
            course). You can of course set npix still in the command
            line.

16.09.2016  montecarlo_module.f90:
 BUGFIX     In the internal heatsource there was a bug. 
            The energy has to immediately be added to the local energy 
            of the cell. I thought that this was done by the
            do_absorption_event(), but that was not the case. So it
            has to be done "by hand". Since so far those people who
            used this mode used it only for very optically thick cells,
            this was not problematic. But if used for optically thin
            cells it will underestimate the dust temperature. That is
            now fixed. See tag Bugfix 16.09.2016.

16.09.2016  montecarlo_module.f90:
 TODO       I think I might need to check if the heatsource and the
            other source terms are appropriately taking into account
            the mirror symmetry option (where only the upper quadrant
            is being modeled). Not yet done.

 BUGFIX     --> Indeed, this is a bug. 
                Bugfix marked with BUGFIX 17.09.2016.

17.09.2016  montecarlo_module.f90:
 BUGFIX     The above mirror symmetry bug fix also applies to the
            thermal emissivity in the frequency-dependent scattering
            Monte Carlo run done before each image. That means that
            until now the contribution to the scattered light by
            the thermal emission IF using mirror symmetry could
            be half what it should be.

16.09.2016  montecarlo_module.f90:
 TODO       Given that the find cell crossing is now so stable that
            it hardly ever leads to out-of-cell errors, but still for
            extraordinarily optically thick cells sometimes crashes
            the code, I think I should implement a very brute-force
            fix for those cases: simply randomly move the photon
            1% of a cell width in a random direction, and recalculate
            in which cell it finds itself. 

16.09.2016  montecarlo_module.f90:
 minibug    See position marked "NOTE (16.09.2016)". I think that this
            is a harmless issue, but maybe at some point I should 
            check this out. Not yet fixed for now.

16.09.2016  montecarlo_module.f90:
 !!         I am now going to allow the MRW to tolerate an occasional
            tiny out-of-cell issue. That way a model does not crash
            after a very long time. Here is what I do (everything
            marked with CHANGE 16.09.2016):

              - In find_closest_wall_spher_lite() I remove the 
                stop statement if the dist.lt.-epsmargin*x0(1).
                Instead I will simply set dist=0.0. It will print
                a warning, but will not crash. In fact, I have
                also put dist=0.0 if dist is between that margin
                and 0. In other words: dist is now always .ge.0.
                The negative dist may have caused some of the
                reported troubles.

              - I have extracted the checking whether the photon
                is in the cell from the modified random walk
                routine and instead put this into an extra
                function called mrw_check_if_in_cell(). This
                function will only stop if the error is really
                bad (more than 10% of the cell size). Otherwise
                it will merely return .false.

              - If the photon package is outside of a cell before
                starting the modified random walk, it will instead
                jiggle the location of the photon package a bit
                and recalculate in which cell we are.

            I hope that this now finally fixes all the out of cell
            problems... Let's see what people report.

            [--> radmc-3d_v0.40_17.09.16.zip]

01.11.2016  mathroutines_module.f90/remap_function()
  bugfix    If we do a remapping of an array with only 1 element,
            then it went wrong. This happened because we are now
            making a setup where we prepare a scattering matrix
            opacity file for a single wavelength for imaging. 
            This caused problems with the remapping. Now I added
            if(nold.gt.1) statements, with in the else-clause
            the statement fnew(inew) = fold(ioldstart), so that
            the opacities will not be cast to 0.

06.11.2016  I would like to implement the possibility to use a non-linear
            grid for the mui-angle (the scattering angle) in the polarized
            mode. The Mie code of the package is currently only doing linear
            grid. But Akimasa Kataoka and I created a modified version that
            can also deal with a refined mui-grid toward mui--> 1 and
            -1. This can be useful for very forward peaked
            scattering. Currently RADMC-3D has a check and stops when the
            mui grid is non-linear, just to warn that internally this is not
            handled.

            Internally RADMC-3D creates its own mui-grid, which is a linear
            grid. It then interpolates all the opacity data on that
            grid. That allows one to use different opacity data for
            different ispec, with different nr of mui-points. If we remove
            the warning stop, then RADMC-3D will make a linear grid with nmu
            equal to the largest nmu of the opacity files. But that will not
            really adopt the refinement regions (because it remains linear).
            One solution could be to internally make a very fine-spaced
            linear mui-grid, but that takes up lots of memory and makes the
            code slower.

            My solution now is that if one specifies nmu=0 in the radmc.inp
            file then RADMC-3D will search for (and read) the file
            scatangle.inp, and will use that as the mui-grid

            Hey, I notice that there is still an old non-used subroutine
            read_scat_angular_grid() in the rtglobal.f90. I think I 
            can/should use that...

  &&        rtglobal_module.f90/read_scat_angular_grid()
            I modified the read_scat_angular_grid() subroutine (which
            was present but not used so far) a bit. It should now
            work as envisioned.

  &++       montecarlo_module.f90/montecarlo_init()
            I now check if the file scattering_angular_grid.inp is
            present. If so, then we call read_scat_angular_grid(1) to
            read this file. If not, then (and only then) we will make
            the scattering angular grid internally with linear spacing. 

  &&        dust_module.f90/read_dustkapscatmat_file()
            I removed the check for non-linear mu grid in the dust
            opacity files. 

            It all compiles, but I have not yet tested it. 

            [--> radmc-3d_v0.40_07.11.16.zip]

12.11.2016  opac/dust_continuum/bohrenhuffman_scatmat/make_scatmat_distr.f90
  BUGFIX    If we use size distributions in the Mie codes for the
            scattering matrix, then the g-factor was averaged wrongly. In
            many cases it was not a great error, but in some cases with very
            wide grain size distributions, it could yield wrong values for
            g. This is NOT a problem for the bohrenhuffman/ directory,
            ONLY for the bohrenhuffman_scatmat/ directory, and in that,
            ONLY for the make_scatmat_distr.f90 code. 

            Fix: The averaging for g must be weighted with kappa_scat.
            
06.12.2016  montecarlo_module.f90/anisoscat_phasefunc()
  BUG!!     The subroutine anisoscat_phasefunc() produces the wrong normalization
            of the phase function! I never used this subroutine before, because
            I always immediately went for the full polarization or just the
            Henyey-Greenstein phase function. But I noticed the problem when
            doing a simple test: making an opacity with full scattering matrix,
            but with all elements other than Z11 set to 0.0. The funny thing
            was that the code then automatically switched to scattering_mode=3
            instead of scattering_mode=5, because it realized that it does not
            need the full polarization stuff. However, scattering_mode=3 
            produced images that had the same shape as images with isotropic
            scattering, but a different factor. I traced it back to the 
            anisoscat_phasefunc() subroutine that returned the Z11, instead of
  BUGFIX    4*pi*Z11/kappa_scat. I now corrected this. Marked BUGFIX 06.12.2016.

            I do not think that many people (any people?) will use this 
            intermediate scattering mode. Either people use isotropic scattering,
            or Henyey-Greenstein or Polarized mode. But it should nevertheless
            be announced in case someone does use it.


14.12.2016  montecarlo_module.f90
  ++        I want to build in a single scattering mode for images, so that for
            the simple case where we only scatter starlight from pointsource 
            stars, and we ignore multiple scattering, we get a smooth image
            without stochastic MC noise.

            Adding: subroutine do_single_scattering() which will calculate the
            scattering source function for this.

            Adding: subroutine walk_cells_optical_depth() which is used by the 
            above subroutine to calculate the optical depth between a star and
            a cell.

24.12.2016  amr_module.f90/amr_write_grid_helper()
  &&        Instead of write(1,*) 0 I now have write(1,*) '0', which
            makes the output file much more compact.

24.12.2016  viewimage.pro
  &         The image writing routine used a format in which 4 pixels 
            were written onto a single line. That caused trouble for
            some other software. Now back to one pixel per line.

==============================================================================
                           VERSION 0.41
==============================================================================

05.02.2017  I notice that the do_single_scattering() name causes confusion.
            This is actually a lambda operator thing. So change the name to
            do_lambda_starlight_single_scattering(). I also change the flag
            camera_single_scat_mode into camera_lambda_starlight_single_scat_mode.
            This is a bit an unwiedly name, but at least it is clearer what
            it means. The main reason I wanted to change this is that I 
            want to implement a true single scattering mode, in which simply
            the Monte Carlo of each photon package is stopped after each
            discrete scattering event. 

            [git:2c6c35a]

05.02.2017  
   +++      Added the possibility of using single scattering or double 
            scattering or n-scattering in the scattering Monte Carlo for
            images and spectra. This is useful for figuring out what is
            the role of multiple scattering in an image you have. This is
            set by the command line option:

              maxnrscat 1

            added to your radmc3d command. Example: run_simple_1, but
            now with scattering_mode_max = 1 in the radmc3d.inp file.
            If you do (after setting up the model and setting the
            scattering_mode_max = 1):

              radmc3d mctherm
              radmc3d image lambdamic 1.0 maxnrscat 1

            then you get the image with only single scattering. You can
            also go back to no scattering:

              radmc3d image lambdamic 1.0 maxnrscat 0

            (even though scattering_mode_max = 1). Or you can check out
            what happens with double scattering:

              radmc3d image lambdamic 1.0 maxnrscat 1

            In this example one can see that the full scattering mode
            produces a very much different image than the case for
            maxnrscat 0 or 1 or 2 etc. Truly multiple scattering is
            apparently important here.

            I now added the corresponding text to the manual.

            [git:5438c29]

  +++       polarization_module.f90, rtglobal_module.f90:
            I have added stuff for the aligned grain thermal emission.
            The reading routine for the alignment direction is done.
            The RT routine for the aligned grains is programmed.
            But still not tested. And we have to create an
            aligned grain mode, remove the dust stuff from the 
            get_src_alp if this mode is on, read the orth and 
            para factors as a function of cos(angle) and frequency,
            call the rt routine. Still lots of stuff to do.

07.02.2017  ADDED ALIGNED GRAIN THERMAL EMISSION
  ++++++    polarization_module.f90, camera_module.f90,
            sources_module.f90, dust_module.f90 
            Added the possibility to treat, in simplified form,
            the thermal absorption and emission by aligned
            grains.

            ---> Compiles, but is still untested!

08.02.2017  First tests appear to work well (after a number of bugfixes).
            Have a look at examples/run_simple_1_align/.

   ++       Added partial alignment: the length of the alignment 
            direction vector field also serves to indicate how
            strongly the grains are aligned: =0.d0 is no alignment,
            =1.d0 is perfect alignment. Partial alignment is
            treated as a linear sum of fully aligned and not
            aligned. 

14.02.2017  Added possibility of doing full Stokes scattering in 2-D
            axisymmetric models. The way this is done is to compute,
            for each time a photon enters a cell, what the source 
            function is like for all azimuthal angles. Essentially
            we smear the scattering source function out over phi.

16.02.2017  Fixed some bugs. One of them was that I implemented it
            only in one place in the montecarlo_module.f90, but 
            forgot to also implement it in another place. Now that
            is fixed and it seems to work. Note that for multiple
            scattering at low number of photons the images are not
            exactly left-right symmetric. That has a simple 
            explanation: for a single photon entering an annular
            cell at some non-radial angle, the left case could be
            forward scattering while the right case would then be
            backward scattering. For single scattering the images
            are always exactly left-right symmetric. For large
            number of photons the images should also become 
            approximately symmetric for multiple-scattering.

            ---> So now the full scattering mode is also implemented
                 in 2-D axisymmetric models!

17.02.2017  Trying to get the alignment and the scattering correct.
            Between git:c69aa50 and git:45f77d2 I tried to bring
            the scattering source addition back into the subroutine
            sources_get_src_alp(), but I keep getting problems.
            One problem was: if I add the scattering source, then
            I must add also the scattering opacity, otherwise the
            j_nu/alpha_nu goes wrong. Another bug was that the 
            src0 obtained from sources_get_src_alp() should be
            used in pol_integrate_rt_aligned() as source function,
            not as emissivity. In git:c69aa50 this was not problematic
            since src0 was anyway 0. But in git:45f77d2 the 
            scattering was included using the src0. 

            Now I still have a difference between the versions
            git:c69aa50 and git:45f77d2, even though this should
            not be the case... Weird...

  Bugfix:   Found the bug: if I add alpha_scat in the get_src_alp, then I
            should not add it again in the pol_integrate_rt_aligned().

            git:12dad22
            
  Test:     I tested the model run_simple_1_align with the current
            version and with git:c69aa50 (which is before I moved
            the scattering source back into get_src_alp for the
            aligned mode). They produce virtually identical images,
            with slight noise at the 1e-14 relative level. So that
            means that the move of the scattering source back to 
            get_src_alp for aligned grains is now finally successful.

19.02.2017  
   +++      I now created my own Mie code in Python. I started from 
            the bhmie.f code of Bruce Draine (from the original code
            from Bohren & Huffman), and converted it systematically
            into Python, but with more flexibility than the original
            code. For instance, it is no longer necessary to have
            the same angular grid between 0-90 degrees as between 
            90-180 degrees. 

            git:3910924

23.02.2017  
 BUG?       Does the Modified Random Walk work for OpenMP? I do not
            see a lock... What if two threads do a MRW in the same
            cell at the same time? The result will simply be one of 
            the two results. I don't expect this to happen often.
            But it is not entirely impossible, especially if one
            uses many threads.

 BUGFIX     OpenMP in scattering Monte Carlo:
            I finally found where the scattering monte carlo in
            OpenMP mode goes astray. The lock was released twice!
            Interestingly this was no problem for the thermal
            monte carlo (where it was also released twice). But
            for the scattering monte carlo it caused a crash 
            about 70% of the time. 

            --> BUGFIX 23.02.2017

            git:4034560

            I also made several changes and bugfixes to the OpenMP stuff, in
            particular in the scattering MC part. I also cleaned that stuff
            a bit up.

            Note: I made several modifications to the OpenMP stuff:
             - Moved the init of the lock outside of the parallel
               region.
             - Removed the PRIVATE(id), added THREADPRIVATE(id)
             - Made mcscat_phasefunc, zmatrix and zcumul threadprivate
             - Introduced ierrpriv to replace ierror in places where
               the ierror should be private.
             - Initialized conflict_counter to 0
             - Removed iphot from PRIVATE
             - Fixed the bug of double lock release...
             - Removed the shared(....) stuff, because that is automatic
             - Made the REDUCTION() statement for scat MC identical to 
               that of therm MC.
             - Moved the continue=.true. out of the if() statement
             - Reformatted the OpenMP stuff to include proper indentations
             - Added omp atomic to the conflict_counter update

 BUGFIX     Now also fixed the OpenMP Modified Random Walk issue: I now put
            a lock around this part of the code.

            git:85bea1b
 
            Merged back to master

26.02.2017  Bug fixed: zmatrix and zcumul should *not* be private in OpenMP.

28.02.2017  I attempted to make the 2-D axisymmetric scattering mode faster
            by putting the loop over angles inside a single routine in the
            polarization_module.f90.  I made everything with 1-D arrays
            (:). But the result was that the code became somewhat slower
            rather than faster. So I reset to the original version (leaving
            this experiment in a branch called "axisymmscat_specialroutine").

01.03.2017  Testing a bit more the OpenMP parallellization. 
            I did the run_simple_1 with various combinations of seeds
  check     and setthread numbers (1, 2, 4 and 8 threads). The good news
            is that the noise level for 8 threads is the same as the
            noise level for 1 thread. This shows that indeed each thread
            uses its own random seed, as it should. Also good news is that
            all results are (almost) the same. The bad news is that there
            appears to be a slight (few percent) difference in the dust
            temperatures very near to the star for 1 thread vs 8 threads.
            This difference is really minor, but it is a slight bit puzzling.
            What I THINK is going on is that in the serial mode (setthread 1)
            the first few photon packages increase the dust temperature from
            0 to some initial value. During this time the typical wavelength
            of re-emission changes dramatically, and so does the opacity.
            The first photon packages might even leave the central cells
            nearly unperturbed because the temperature is extremely low,
            so that the Rosseland mean is extremely low, too. Only once the
            first few packages have gone through that cell this will change
            and the opacity increases drastically. With the parallel mode
            up to 8 photon packages do that work together, so even within 
            the first photon 8 packages the opacity might have already 
            increased a lot. Why that *reduces* the temperature, I do not
            know. The differences are small, and they become smaller for
            larger nphot, so for now I will not worry too much.

06.03.2017  montecarlo_module.f90
  bugfix    If you use unweighted photons (i.e. if you explicitly set
            mc_weighted_photons = 0 in the radmc3d.inp file) AND if you
            use OpenMP parallel mode with setthreads 2 or so, then there
            was a bug. The "energy" variable is a local variable, and it
            was precomputed outside of the parallel loop. That meant that
            the energy was ok for thread 0, but for all other threads, the
            energy was 0.0. I now fixed this by adding !$OMP PARALLEL 
            statements there where energy is calculated (and also where
            it is put to 0.5*energy for mirror mode).

  bugfix    stars_module.f90:
            stellarsrc_templates(1,itempl) = dummy
            was replaced by:
            stellarsrc_templates(1,itempl) = dummy / fourpi

06.03.2017  montecarlo_module.f90
   why?     It seems that I install the opacities twice for the scattering
            and/or mcmono Monte Carlo. The find_dust_kappa_interpol() is
            called in the montecarlo_init() and again in the 
            do_monte_carlo_scattering(). This caused a problem with the
            mcmono in scattering_mode=0. But it is also useless and thus
            potentially confusing. 

  remove    I comment out these seemingly useless double lines of code.
            I redo the selftest to check if this did not break anything.
            ---> The self-test (incl scattering) has been passed, so 
            this was indeed useless code.

07.03.2017  montecarlo_module.f90
  bufix     The count messages (e.g. Thread: 2 Photon nr: 997000) did not work
            correctly in OpenMP mode. Now I use if(mod(cnt,countwrite).eq.0)
            to decide when to write a message. Works better.

11.03.2017  montecarlo_module.f90
  BUGFIX!   In the thermal monte carlo, after a thermal absorption / 
            re-emission event, the photpgk must be updated: the Q=U=V=0
            and the n(1:3) set to the new direction. Is now fixed!

15.03.2017  rtglobal_module.f90:
  BUGFIX!   When reading scattering_angular_grid.inp the theta grid must
            internally be converted into radian!
            polarization_module.f90:
            Check in polarization_randomorient_mc_scatter() that the thetai
            grid has the right boundaries.
            (marked as Bugfix 2017.03.15)

18.03.2017  Continue with the maxdphi stuff: in spherical coordinates there
            should be a possibility to limit the maximum angle change of the
            ray with the origin. I now implemented the trilinear interpolation
            in sources_find_srcalp_interpol(). 

      !!    I noticed that I already implemented maxdphi in several other
            parts of the code, but somehow this never landed into this
            branch. I think this was a mistake of forgetting to switch
            branch. Anyway: it is already in amrray_module.f90. See the
            maxdeltasina keyword.

20.03.2017  It seems that the maxdphi stuff is now finished and works.
      !!    I now make this the default! As of now the angle of the 
            head of the ray w.r.t. the origin of the (spherical) 
            coordinate system can not swap too much within a single
            ray segment. 

21.03.2017  Re-implemented the circular images stuff. Finally... This is
            particularly useful for 1-D models as well as for making 
            spectra of 2-D axially symmetric models. But I need to add
            some stuff about this in the manual. Still to do. I added
            it to the run_spher* examples, though. For now that should
            be enough.

27.03.2017  montecarlo_module.f90
  Cleanup   In the thermal Monte Carlo I completely removed the computation
            of the scattering source function. That was a lot of code, 
            but it was never used. It should also not be used, because
            it would simply yield very noisy images and spectra. The
            scattering source function should only be computed with the
            scattering Monte Carlo. So I cleaned out all stuff related
            to incl_scatsrc_mctherm. 

            main.f90, rtglobal_module.f90
            I commented out all stuff related to incl_scatsrc_mctherm.

04.07.2017  amr_module.f90
  BUG       Attila Juhasz found a bug in amr_get_corner_vertexindex()!
            It appears when calling this subroutine for AMR in spherical
            coordinates. The if((iz.ne.1).and.(iz.ne.amr_grid_nz))
            clause (and similar clauses) is wrong, because iz is not
            the index of the main grid, but just 1 or 2... However,
            this was only part of a safety check, and it only occurs
            when using periodic boundary conditions, which is the case
            for 3-D spherical coordinates only.

  FIXED     Nevertheless it is a bug and must be fixed. I now check
            (in case of a possible coordinate mismatch in a coordinate
            that is cyclic) if the difference is equal to the periodic
            length. If so, then it is false alarm.

